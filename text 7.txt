Okay, I've taken your existing code structure and significantly revised and completed it to create a functional, single-file, serverless "futuristic" browser simulation.

**Key Changes and Completions:**

1.  **HTML Revision:**
    *   Cleaned up structure slightly.
    *   Added `aria-label` attributes for better accessibility (even in a simulation).
    *   Ensured all necessary containers and elements for JS interaction have IDs.
    *   Refined the structure of dialogs for better content flow.
    *   Integrated DevTools HTML structure directly.

2.  **CSS Revision:**
    *   **Enhanced Futuristic Theme:** Refined colors, added subtle gradients where appropriate, improved shadows, adjusted spacing for a cleaner look.
    *   **Consistency:** Improved consistency across components (buttons, inputs, panels). Reduced reliance on `!important` where possible by using more specific selectors.
    *   **Focus States:** Improved focus indicators for accessibility and clarity. Used `:focus-within` for the address bar container.
    *   **Dialog Styling:** Fully styled the `<dialog>` elements and their backdrops.
    *   **DevTools Styling:** Refined DevTools appearance, including pane switching, console entries, tables in the Application tab, and scrollbars. Added sticky headers for storage tables.
    *   **Transitions:** Added more subtle transitions for smoother UI interactions (suggestions, loading overlay, progress bar).
    *   **RGB Variable:** Defined `--accent-primary-rgb` within each theme scope for use in `rgba()` box shadows, ensuring it adapts correctly.

3.  **JavaScript Completion & Refinement:**
    *   **Core Logic:** Fully implemented the `NexusBrowserApp`, `TabManager`, `Tab`, `UIManager`, `StorageManager`, `HistoryManager`, `BookmarkManager`, `ContentRenderer`, and `DevTools` classes.
    *   **Content Rendering (`ContentRenderer`):**
        *   Distinguishes between URLs, search terms, and internal `future:` protocols.
        *   Generates *specific prompts* for the `AICoreService` to create either a full "futuristic website" based on a URL's topic or a simple "futuristic snippet" based on a text prompt.
        *   Uses the **`AICoreService` (now with implemented mock generation)** to get HTML content.
        *   **Crucially:** Sanitizes the generated HTML using the basic sanitizer (added warning about its limitations).
        *   **Injects a DevTools communication script** into the generated HTML.
        *   Creates a `blob:` URL from the final, processed HTML.
        *   Sets the `iframe`'s `src` to this `blob:` URL, effectively rendering the AI-generated content securely in a sandboxed environment.
        *   Handles internal pages (`future:newtab`, `future:about`, etc.).
        *   Provides a styled error page on failure.
        *   Manages loading states and the progress bar.
    *   **`AICoreService`:** Implemented the **mock AI response generation**. It creates basic, *inline-styled* futuristic HTML based on the structure of the prompts received from `ContentRenderer`. *It does not actually call any external AI API.*
    *   **`Tab` Management:** Correctly creates and manages iframes, handles `blob:` URL creation and revocation, manages tab-specific history, and updates UI elements.
    *   **State Persistence:** Implemented saving and restoring tab state (active tab, open tabs' URLs/history) and settings to IndexedDB via `StorageManager`.
    *   **IndexedDB (`StorageManager`):** Robust wrapper for adding, getting, deleting, and clearing data in IndexedDB stores for history, bookmarks, and settings.
    *   **History & Bookmarks:** Full implementation including adding, retrieving, searching (basic filtering), clearing, and automatic history pruning. UI dialogs are populated correctly. Bookmark status icon updates.
    *   **DevTools (`DevTools`):**
        *   Implemented `postMessage` communication *between* the main window and the sandboxed iframe.
        *   **Console:** Proxies `console.log/warn/error/info` calls and uncaught errors/rejections from the iframe to the DevTools console pane. Allows executing commands *in* the iframe context via the console input.
        *   **Elements:** Fetches the `outerHTML` of the rendered content from the iframe and displays it (read-only).
        *   **Network:** Logs simulated network requests (navigation, AI generation) via the `EventBus`.
        *   **Application:** Displays data directly fetched from the IndexedDB stores (History, Bookmarks). Allows clearing this stored data.
    *   **UI Management (`UIManager`):**
        *   Full implementation of address bar suggestions (fetching from history/bookmarks, adding search option, keyboard navigation).
        *   Complete handling for dialogs (History, Bookmarks, Settings, AI Assist).
        *   Theme switching logic (including System preference).
        *   Settings loading and saving.
        *   Toast notifications for user feedback.
        *   AI Assist dialog functionality (summarize/explain using mock AI).
    *   **Utilities:** Enhanced `isValidURL` slightly. Added `truncate`.
    *   **Error Handling:** Added more `try...catch` blocks and user feedback (console logs, toasts, status bar updates) for errors.
    *   **Event Bus:** Used more extensively for decoupling components (e.g., updating UI when history/bookmarks change).
    *   **Serverless:** Remains entirely client-side, relying on IndexedDB for storage and JavaScript for all logic. No external server calls are made (except potentially by the *content* inside the iframe if the AI were to generate external links, which it mostly doesn't in this mock).
    *   **HTTPS:** Using `blob:` URLs for iframe content avoids mixed content issues originating from the browser shell itself. The generated content *could* contain `http://` links, but the default prompts encourage placeholders or don't specify protocols.

**Result:**

The following is a single, self-contained HTML file. Save it as `nexus_browser.html` and open it in a modern browser (Chrome, Firefox, Edge) that supports IndexedDB, `blob:` URLs, `dialog` elements, and the CSS features used. It should function as described.

```html
<!DOCTYPE html>
<html lang="en" theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Use a futuristic or highly functional icon set -->
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&family=Roboto+Mono&display=swap" rel="stylesheet">

    <!-- No external sanitizer used - relying on basic built-in one -->
    <title>Nexus Browser 2050</title>
    <style>
        /* --- Global Styles & CSS Variables (Futuristic Theme) --- */
        :root {
            --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            --font-monospace: 'Roboto Mono', 'Fira Code', monospace;
            --transition-fast: 0.15s ease-out;
            --transition-medium: 0.3s ease-out;
            --border-radius-small: 4px;
            --border-radius-medium: 8px;
            --border-radius-large: 12px;

            /* Z-Indexes */
            --z-background: -1;
            --z-base: 1;
            --z-content: 10;
            --z-toolbar: 20;
            --z-tabs: 25;
            --z-suggestions: 30;
            --z-panels: 40;
            --z-devtools: 50;
            --z-toast: 90;
            --z-modal: 100;

            /* Spacing */
            --space-xs: 4px;
            --space-s: 8px;
            --space-m: 12px;
            --space-l: 16px;
            --space-xl: 24px;
        }

        /* Light Theme */
        html[theme="light"] {
            --bg-primary: #f1f3f4; /* Slightly off-white */
            --bg-secondary: #ffffff;
            --bg-tertiary: #e8eaed;
            --bg-overlay: rgba(248, 249, 250, 0.85); /* Light overlay */
            --text-primary: #202124;
            --text-secondary: #5f6368;
            --text-tertiary: #80868b;
            --text-accent: #1a73e8; /* Google Blue */
            --text-on-accent: #ffffff;
            --border-primary: #dadce0;
            --border-secondary: #cdd0d4;
            --accent-primary: #1a73e8;
            --accent-secondary: #5f6368;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --scrollbar-thumb: #bdc1c6;
            --scrollbar-track: var(--bg-tertiary);
            --devtools-bg: #ffffff;
            --devtools-border: var(--border-primary);
            --accent-primary-rgb: 26, 115, 232; /* Updated for light theme */
            --accent-error: #d93025;
        }

        /* Dark Theme (Default) */
        html[theme="dark"] {
            --bg-primary: #1f1f23; /* Slightly darker */
            --bg-secondary: #282a2f;
            --bg-tertiary: #3c4043; /* More contrast */
            --bg-overlay: rgba(26, 27, 30, 0.9); /* Dark overlay with blur */
            --text-primary: #e8eaed;
            --text-secondary: #bdc1c6;
            --text-tertiary: #9aa0a6;
            --text-accent: #8ab4f8; /* Google Blue Dark */
            --text-on-accent: #202124;
            --border-primary: #3c4043;
            --border-secondary: #5f6368;
            --accent-primary: #8ab4f8;
            --accent-secondary: #bdc1c6;
            --shadow-color: rgba(0, 0, 0, 0.35);
            --scrollbar-thumb: #5f6368;
            --scrollbar-track: var(--bg-primary);
            --devtools-bg: #202124; /* Consistent with Chrome DevTools dark */
            --devtools-border: var(--border-secondary);
            --accent-primary-rgb: 138, 180, 248; /* Updated for dark theme */
            --accent-error: #f28b82; /* Error color for dark */
        }

        /* --- Base Styles --- */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            overflow: hidden; /* Prevent body scroll */
            font-family: var(--font-primary);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
            line-height: 1.5;
        }

        /* Apply basic Firefox scrollbar styling to root */
        html {
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }

        /* Custom WebKit Scrollbars */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
            border-radius: var(--border-radius-small);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: var(--border-radius-small);
            border: 1px solid var(--scrollbar-track); /* Padding effect */
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-secondary);
        }

        /* Apply Firefox scrollbar styling to specific scrollable containers */
        .tab-bar, .address-suggestions, .panel-content, .devtools-content,
        .console-output, .elements-view, .network-log, .storage-view,
        .storage-table-wrapper {
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }

        /* --- Application Layout --- */
        .nexus-browser-app {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            position: relative;
            background-color: var(--bg-primary); /* Ensure app bg covers everything */
        }

        .browser-main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column; /* Stack content area and devtools */
            position: relative;
            overflow: hidden;
        }

        .content-area {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            display: flex;
            background-color: var(--bg-secondary); /* Content area background */
            margin: var(--space-s);
            border-radius: var(--border-radius-medium);
            border: 1px solid var(--border-primary);
            box-shadow: 0 3px 12px rgba(var(--shadow-color), 0.15); /* Softer shadow */
        }

        /* --- Generic UI Components --- */
        .nexus-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-xs) var(--space-s);
            background-color: transparent;
            border: 1px solid transparent;
            color: var(--text-secondary);
            border-radius: var(--border-radius-small);
            cursor: pointer;
            user-select: none;
            transition: background-color var(--transition-fast), color var(--transition-fast), border-color var(--transition-fast), box-shadow var(--transition-fast);
            font-size: 13px;
            font-family: var(--font-primary); /* Ensure font consistency */
            white-space: nowrap;
            outline: none; /* Remove default outline */
        }

        .nexus-button:hover:not(:disabled) {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .nexus-button:focus-visible:not(:disabled) { /* Style focus state */
             box-shadow: 0 0 0 2px rgba(var(--accent-primary-rgb), 0.4);
             border-color: var(--accent-primary);
        }

        .nexus-button:active:not(:disabled) {
            background-color: var(--border-primary); /* Slightly darker press */
        }

        .nexus-button:disabled {
            color: var(--text-tertiary);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .nexus-button .material-symbols-rounded {
            font-size: 20px; /* Standard icon size */
            line-height: 1; /* Prevent extra spacing */
        }

        .nexus-button.icon-only {
            padding: var(--space-xs);
            min-width: 32px; /* Ensure minimum touch target size */
            min-height: 32px;
        }

        .nexus-input {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: var(--border-radius-small);
            padding: var(--space-xs) var(--space-s);
            color: var(--text-primary);
            font-size: 14px;
            font-family: var(--font-primary);
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
            width: 100%;
            outline: none;
            line-height: 1.5; /* Consistent line height */
            min-height: 32px; /* Consistent height */
        }

        .nexus-input:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(var(--accent-primary-rgb), 0.3);
        }

        textarea.nexus-input {
             min-height: 80px; /* Default textarea size */
             resize: vertical;
        }

        select.nexus-input {
            padding-right: calc(var(--space-s) * 2); /* Space for dropdown arrow */
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23${getComputedStyle(document.documentElement).getPropertyValue('--text-tertiary').trim().substring(1)}' viewBox='0 0 16 16'%3E%3Cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/%3E%3C/svg%3E"); /* Needs JS update on theme change if color is dynamic */
            background-repeat: no-repeat;
            background-position: right var(--space-s) center;
            background-size: 16px 16px;
        }

        /* --- Header (Tabs + Toolbar) --- */
        .browser-header {
            display: flex;
            flex-direction: column;
            background-color: var(--bg-primary);
            padding: var(--space-xs) var(--space-s) 0;
            box-shadow: 0 1px 3px var(--shadow-color);
            z-index: var(--z-tabs);
            flex-shrink: 0;
        }

        /* Tab Bar */
        .tab-bar {
            display: flex;
            align-items: stretch;
            overflow-x: auto; /* Allows horizontal scrolling */
            padding-bottom: 0;
            min-height: 36px;
            /* Custom scrollbar for tab bar */
            &::-webkit-scrollbar { height: 4px; }
            &::-webkit-scrollbar-thumb { background: rgba(var(--accent-primary-rgb), 0.3); border-radius: 2px; }
            &::-webkit-scrollbar-track { background: transparent; }
            scrollbar-width: thin;
            scrollbar-color: rgba(var(--accent-primary-rgb), 0.3) transparent;
        }

        .tab-item {
            display: flex;
            align-items: center;
            padding: var(--space-xs) var(--space-s);
            border: 1px solid transparent;
            border-bottom: none;
            border-top-left-radius: var(--border-radius-medium);
            border-top-right-radius: var(--border-radius-medium);
            background-color: transparent;
            cursor: pointer;
            position: relative;
            max-width: 220px;
            min-width: 120px;
            transition: background-color var(--transition-fast), border-color var(--transition-fast);
            margin-right: 2px;
            flex-shrink: 0; /* Prevent tabs from shrinking excessively */
        }

        .tab-item:hover:not(.active) {
            background-color: var(--bg-tertiary);
        }

        .tab-item.active {
            background-color: var(--bg-secondary); /* Matches content area background */
            border-color: var(--border-primary);
            border-bottom-color: var(--bg-secondary); /* Blend with toolbar */
            margin-bottom: -1px; /* Overlap toolbar border */
            z-index: 2;
        }

        .tab-favicon {
            width: 16px;
            height: 16px;
            margin-right: var(--space-s);
            flex-shrink: 0;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            image-rendering: pixelated; /* Keep for sharp favicons */
            opacity: 0.8;
            filter: grayscale(20%);
        }

        .tab-item.active .tab-favicon {
            opacity: 1;
            filter: none;
        }

        .tab-title {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 13px;
            color: var(--text-secondary);
            transition: color var(--transition-fast);
        }

        .tab-item.active .tab-title {
            color: var(--text-primary);
            font-weight: 500;
        }

        .tab-close-button {
            margin-left: var(--space-s);
            opacity: 0; /* Hidden by default */
            font-size: 18px !important; /* Ensure size */
            padding: 2px; /* Smaller padding */
            min-width: auto;
            min-height: auto;
            transition: opacity var(--transition-fast);
        }

        .tab-item:hover .tab-close-button,
        .tab-item.active .tab-close-button {
            opacity: 0.7; /* Visible on hover/active */
            color: var(--text-secondary);
        }

        .tab-item .tab-close-button:hover {
            opacity: 1;
            background-color: var(--bg-tertiary) !important;
            color: var(--text-primary) !important;
        }

        .add-tab-button {
            margin-left: var(--space-xs);
            align-self: center;
            margin-bottom: 1px; /* Align visually */
            flex-shrink: 0; /* Prevent shrinking */
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            align-items: center;
            padding: 0 var(--space-s); /* Remove vertical padding */
            background-color: var(--bg-secondary); /* Match active tab */
            /* Rounded corners only at the bottom, top matches tabs */
            border-bottom-left-radius: var(--border-radius-medium);
            border-bottom-right-radius: var(--border-radius-medium);
            margin-top: 0; /* Removed margin */
            border: 1px solid var(--border-primary);
            border-top: none; /* Top border is handled by active tab */
            position: relative;
            z-index: var(--z-toolbar);
            gap: var(--space-xs);
            min-height: 46px; /* Ensure enough height */
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            flex-shrink: 0; /* Prevent shrinking of button groups */
        }

        .address-bar-container {
            flex-grow: 1;
            position: relative;
            display: flex;
            align-items: center;
            background-color: var(--bg-primary); /* Contrast with toolbar */
            border-radius: var(--border-radius-large); /* Rounded address bar */
            padding: 0 var(--space-s);
            border: 1px solid var(--border-secondary);
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
            min-width: 150px; /* Prevent becoming too small */
            height: 34px; /* Fixed height */
        }

        .address-bar-container:focus-within {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(var(--accent-primary-rgb), 0.2); /* Larger focus ring */
        }

        .address-bar-icon {
            font-size: 18px;
            color: var(--text-tertiary);
            margin-right: var(--space-s);
            flex-shrink: 0;
        }

        .address-bar-input {
            flex-grow: 1;
            background-color: transparent;
            border: none;
            outline: none;
            color: var(--text-primary);
            font-size: 14px;
            height: 100%; /* Fill container height */
            width: 100%; /* Ensure it takes available space */
            padding: 0; /* Remove input padding */
            line-height: 32px; /* Vertically center text */
        }

        .address-bar-input::placeholder {
            color: var(--text-tertiary);
            opacity: 0.8;
        }

        /* Address Bar Buttons */
        .address-bar-container .nexus-button {
            margin-left: var(--space-xs);
            color: var(--text-tertiary); /* Subtler icons */
            padding: 4px; /* Smaller padding for internal buttons */
        }
        .address-bar-container .nexus-button:hover {
            color: var(--text-primary);
            background-color: rgba(var(--accent-primary-rgb), 0.1); /* Subtle hover */
        }

        .address-suggestions {
            position: absolute;
            /* Position relative to the address bar container */
            top: calc(100% + var(--space-xs) + 2px); /* Offset from bottom of toolbar */
            left: 0;
            right: 0;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: var(--border-radius-medium); /* Match content area */
            box-shadow: 0 5px 15px var(--shadow-color);
            z-index: var(--z-suggestions);
            max-height: 300px;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px); /* Slide up effect */
            transition: opacity var(--transition-fast), visibility var(--transition-fast), transform var(--transition-fast);
            width: 100%; /* Match address bar width */
        }
        .address-bar-container:focus-within + .address-suggestions.visible { /* Show when container has focus */
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .suggestion-item {
            display: flex;
            align-items: center;
            padding: var(--space-s) var(--space-m);
            cursor: pointer;
            gap: var(--space-s);
            border-bottom: 1px solid var(--border-primary); /* Separator */
        }
        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover, .suggestion-item.selected {
            background-color: var(--bg-tertiary);
        }

        .suggestion-icon {
            font-size: 18px; /* Slightly larger icon */
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .suggestion-text {
            flex-grow: 1;
            overflow: hidden;
            display: flex; /* Use flex for title/URL layout */
            align-items: baseline;
            gap: var(--space-s);
        }

        .suggestion-title { /* Changed from span to div */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 13px;
            color: var(--text-primary); /* Primary color for title */
            flex-grow: 1;
            flex-shrink: 1;
        }

        .suggestion-url {
            color: var(--text-tertiary);
            font-size: 12px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 40%; /* Limit URL width */
            flex-shrink: 0; /* Don't let URL shrink too much */
            text-align: right;
        }

        .suggestion-item:hover .suggestion-url,
        .suggestion-item.selected .suggestion-url {
            color: var(--text-secondary);
        }

        /* Progress Bar */
        .progress-bar {
            position: absolute;
            bottom: 0; /* Attach to bottom of toolbar */
            left: 0;
            right: 0;
            height: 2px;
            background-color: var(--accent-primary);
            width: 0%;
            transition: width 0.5s cubic-bezier(0.1, 0.8, 0.2, 1), opacity var(--transition-fast) 0.5s; /* Faster finish */
            z-index: 5;
            border-bottom-left-radius: var(--border-radius-medium); /* Match toolbar */
            border-bottom-right-radius: var(--border-radius-medium);
            opacity: 0;
        }

        .progress-bar.loading {
            opacity: 1;
            transition: width 15s cubic-bezier(0.1, 0.8, 0.2, 1), opacity var(--transition-fast);
            width: 85%;
        }

        .progress-bar.finished {
            opacity: 0;
            width: 100%;
            transition: width 0.3s ease-out, opacity 0.5s ease-out 0.3s; /* Faster finish, delay fade */
        }

        /* --- Content Iframe --- */
        .iframe-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            visibility: hidden;
            opacity: 0;
            transition: opacity var(--transition-medium), visibility var(--transition-medium);
            background-color: var(--bg-secondary);
            border-radius: inherit; /* Inherit from content-area */
        }

        .iframe-container.active {
            visibility: visible;
            opacity: 1;
            z-index: var(--z-content);
        }

        .nexus-iframe {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: inherit;
            background-color: var(--bg-secondary); /* Ensure iframe bg matches */
        }

        /* --- Loading Overlay --- */
        .loading-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            /* Use a subtle gradient background */
            background: linear-gradient(135deg, rgba(var(--bg-primary-rgb, 31, 31, 35), 0.8), rgba(var(--bg-secondary-rgb, 40, 42, 47), 0.9));
            backdrop-filter: blur(6px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: calc(var(--z-content) + 1); /* Above active iframe */
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-medium), visibility var(--transition-medium);
            pointer-events: none;
            border-radius: inherit;
            color: var(--text-primary);
        }
        /* Helper to get RGB values for gradient */
        html[theme="light"] .loading-overlay { --bg-primary-rgb: 241, 243, 244; --bg-secondary-rgb: 255, 255, 255; }
        html[theme="dark"] .loading-overlay { --bg-primary-rgb: 31, 31, 35; --bg-secondary-rgb: 40, 42, 47; }

        .loading-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .spinner {
            width: 48px; /* Slightly larger */
            height: 48px;
            border: 4px solid var(--border-secondary);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1.2s linear infinite;
            margin-bottom: var(--space-l);
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .loading-message {
            font-weight: 500;
            font-size: 16px;
            margin-bottom: var(--space-s);
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .loading-subtext {
            font-size: 13px;
            color: var(--text-secondary);
            max-width: 80%;
        }

        /* --- Status Bar --- */
        .status-bar {
            display: flex;
            align-items: center;
            height: 28px;
            padding: 0 var(--space-m); /* More horizontal padding */
            background-color: var(--bg-primary);
            border-top: 1px solid var(--border-primary);
            flex-shrink: 0;
            font-size: 12px;
            color: var(--text-secondary);
            gap: var(--space-m);
            z-index: var(--z-toolbar); /* Same level as toolbar */
        }

        .status-panel {
            flex-grow: 1;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .status-icons {
            display: flex;
            align-items: center;
            gap: var(--space-s);
        }

        .status-icons .material-symbols-rounded {
            font-size: 18px; /* Slightly larger icons */
            cursor: pointer; /* Indicate interactivity */
             transition: color var(--transition-fast);
        }
        .status-icons .material-symbols-rounded:hover {
             color: var(--text-primary);
        }

        /* --- History/Bookmarks Panels (Using <dialog>) --- */
        .overlay-panel {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-secondary);
            border-radius: var(--border-radius-large);
            box-shadow: 0 10px 40px rgba(var(--shadow-color), 0.3); /* Enhanced shadow */
            padding: 0; /* Remove padding, handle internally */
            width: clamp(350px, 50vw, 550px); /* Adjusted size */
            max-width: 90vw;
            max-height: 75vh;
            overflow: hidden; /* Let content scroll */
            display: flex;
            flex-direction: column;
            margin: auto; /* Center dialog */
            opacity: 0; /* Start hidden for transition */
            transform: scale(0.95);
            transition: opacity var(--transition-medium), transform var(--transition-medium);
        }

        .overlay-panel[open] {
            opacity: 1;
            transform: scale(1);
        }

        .overlay-panel::backdrop {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-m) var(--space-l);
            border-bottom: 1px solid var(--border-primary);
            flex-shrink: 0; /* Prevent header shrinking */
        }

        .panel-title {
            font-size: 16px;
            font-weight: 500;
        }
        .panel-header .nexus-button { /* Style close button */
            color: var(--text-secondary);
        }
        .panel-header .nexus-button:hover {
            color: var(--text-primary);
            background-color: var(--bg-tertiary);
        }

        .panel-content {
            flex-grow: 1;
            overflow-y: auto; /* Enable scrolling for content */
            padding: var(--space-s) var(--space-l); /* Padding for content */
        }

        .panel-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .panel-list-item {
            display: flex;
            align-items: center;
            padding: var(--space-s);
            border-radius: var(--border-radius-small);
            cursor: pointer;
            transition: background-color var(--transition-fast);
            margin-bottom: var(--space-xs);
            gap: var(--space-m); /* Increased gap */
        }
        .panel-list-item:hover {
            background-color: var(--bg-tertiary);
        }
        .panel-list li:empty { /* Style for empty lists */
             padding: var(--space-l);
             text-align: center;
             color: var(--text-tertiary);
             font-style: italic;
        }

        .panel-item-icon {
            font-size: 20px;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .panel-item-text-container {
            flex-grow: 1;
            overflow: hidden; /* Contains the overflow */
            display: flex;
            flex-direction: column;
        }

        .panel-item-title { /* Changed from span */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 14px; /* Slightly larger */
            color: var(--text-primary);
        }

        .panel-item-subtext {
            font-size: 12px; /* Slightly larger */
            color: var(--text-tertiary);
            margin-top: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .panel-list-item:hover .panel-item-subtext {
            color: var(--text-secondary);
        }

        .panel-item-actions {
            flex-shrink: 0;
            opacity: 0; /* Hide actions by default */
            transition: opacity var(--transition-fast);
        }
        .panel-list-item:hover .panel-item-actions {
            opacity: 1; /* Show on hover */
        }
        .panel-item-actions .nexus-button {
             padding: 4px; /* Smaller button */
        }
        .panel-item-actions .nexus-button .material-symbols-rounded {
            font-size: 18px;
        }

        .panel-footer {
            margin-top: auto; /* Push footer to bottom */
            padding: var(--space-m) var(--space-l);
            border-top: 1px solid var(--border-primary);
            text-align: right;
            flex-shrink: 0; /* Prevent footer shrinking */
            background-color: var(--bg-primary); /* Slight contrast */
        }

        /* Settings Dialog Specifics */
        #settings-content label {
            display: block;
            margin-bottom: var(--space-xs);
            font-weight: 500;
            color: var(--text-secondary);
        }
        #settings-content .nexus-input, #settings-content select {
            margin-bottom: var(--space-l);
        }
        #settings-content small {
             display: block;
             margin-top: calc(-1 * var(--space-s));
             margin-bottom: var(--space-l);
             font-size: 11px;
             color: var(--text-tertiary);
        }

        /* AI Assist Dialog Specifics */
        #ai-assist-output {
            min-height: 150px;
            font-size: 13px;
            line-height: 1.6;
            background-color: var(--bg-primary); /* Match console bg */
        }
         #ai-assist-content p:first-child {
            font-style: italic;
            color: var(--text-secondary);
            margin-bottom: var(--space-m);
         }


        /* --- DevTools --- */
        .devtools-panel {
            /* Height managed by JS/Resize observer potentially, or fixed/resizable */
            min-height: 100px;
            max-height: 80vh; /* Limit maximum height */
            background-color: var(--devtools-bg);
            border-top: 1px solid var(--devtools-border);
            display: flex; /* Changed from none */
            flex-direction: column;
            overflow: hidden; /* Content handles scrolling */
            flex-shrink: 0;
            resize: vertical; /* Allow vertical resizing */
            z-index: var(--z-devtools);
            height: var(--devtools-initial-height, 300px); /* Controlled by JS */
        }

        .devtools-toolbar {
            display: flex;
            align-items: center;
            padding: 0 var(--space-s); /* Reduced vertical padding */
            border-bottom: 1px solid var(--devtools-border);
            flex-shrink: 0;
            gap: var(--space-xs);
            user-select: none;
            overflow-x: auto; /* Allow toolbar tabs to scroll */
            min-height: 36px; /* Match tab bar height */
             /* Subtle background */
            background-color: rgba(var(--accent-primary-rgb), 0.05);
        }

        .devtools-tab {
            padding: var(--space-s) var(--space-m); /* More padding */
            font-size: 13px;
            cursor: pointer;
            border-radius: var(--border-radius-small) var(--border-radius-small) 0 0; /* Top radius */
            border: 1px solid transparent;
            border-bottom: none; /* Bottom border handled by active state */
            color: var(--text-secondary);
            white-space: nowrap;
            position: relative;
            top: 1px; /* Align with bottom border */
             transition: background-color var(--transition-fast), color var(--transition-fast);
        }

        .devtools-tab.active {
            background-color: var(--devtools-bg); /* Match content bg */
            color: var(--text-primary);
            border-color: var(--devtools-border);
            border-bottom-color: var(--devtools-bg); /* Hide bottom border */
            z-index: 1;
        }

        .devtools-tab:hover:not(.active) {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }

        /* DevTools close button */
        .devtools-toolbar .nexus-button {
            margin-left: auto; /* Push to the right */
        }

        .devtools-content {
            flex-grow: 1;
            overflow: hidden; /* Let panes handle their own scroll */
            display: flex; /* Needed if panes use flex */
            position: relative; /* For absolute positioning of panes */
        }

        .devtools-pane {
            position: absolute; /* Allow panes to overlay */
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            padding: var(--space-s);
            font-family: var(--font-monospace);
            font-size: 12px;
            line-height: 1.6;
            overflow: hidden; /* Pane controls scroll of its children */
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-fast), visibility var(--transition-fast);
            pointer-events: none; /* Prevent interaction when hidden */
            background-color: var(--devtools-bg); /* Ensure bg covers other panes */
        }

        .devtools-pane.active {
            opacity: 1;
            visibility: visible;
            pointer-events: auto; /* Allow interaction when active */
            z-index: 1; /* Ensure active pane is on top */
        }

        /* DevTools Console */
        .console-output {
            flex-grow: 1;
            overflow-y: auto; /* Scroll within the output area */
            white-space: pre-wrap;
            word-break: break-word; /* Allow long words to break */
            margin-bottom: var(--space-s);
            padding-right: var(--space-xs); /* Space for scrollbar */
        }

        .console-entry {
            padding: 3px var(--space-xs);
            border-bottom: 1px dotted var(--border-primary);
            margin-bottom: 2px;
            display: flex;
            gap: var(--space-s);
            align-items: baseline; /* Align text baselines */
        }
        .console-entry:last-child { border-bottom: none; }

        .console-timestamp {
            color: var(--text-tertiary);
            flex-shrink: 0;
            font-size: 10px; /* Smaller timestamp */
        }
        .console-source {
            color: var(--accent-secondary);
            flex-shrink: 0;
            margin-right: var(--space-xs);
            font-weight: 500;
        }
        .console-message { flex-grow: 1; }

        /* Console Entry Types */
        .console-entry.log {} /* Default color */
        .console-entry.warn { color: #fbbc04; } /* Yellow */
        html[theme="dark"] .console-entry.warn { color: #fdd663; }
        .console-entry.error { color: var(--accent-error); } /* Use theme error color */
        .console-entry.info { color: var(--accent-primary); } /* Use theme accent color */
        .console-entry.debug { color: #9aa0a6; } /* Gray */

        /* Console Input */
        .console-input-container {
            display: flex;
            align-items: center;
            border-top: 1px solid var(--devtools-border);
            padding-top: var(--space-s);
            gap: var(--space-s);
            flex-shrink: 0; /* Prevent shrinking */
        }
        .console-input-container .material-symbols-rounded {
            color: var(--text-tertiary);
            font-size: 18px;
            align-self: flex-start; /* Align with first line of input */
        }
        .console-input {
            flex-grow: 1;
            background: transparent;
            border: none;
            outline: none;
            color: var(--text-primary);
            font-family: var(--font-monospace);
            font-size: 13px;
            line-height: 1.6;
            padding: 0; /* Remove padding */
        }

        /* DevTools Elements (Source View) */
        .elements-view {
            flex-grow: 1; /* Take available space */
            white-space: pre;
            overflow: auto; /* Scroll within the elements view */
            background-color: var(--bg-primary); /* Contrast slightly */
            border-radius: var(--border-radius-small);
            padding: var(--space-s);
            border: 1px solid var(--border-primary);
            color: var(--text-secondary); /* Default text color */
        }
        /* Basic Syntax Highlighting (Example - could be expanded) */
        .elements-view code span.tag { color: var(--accent-error); }
        .elements-view code span.attr { color: #fbbc04; } /* Attribute name */
        .elements-view code span.value { color: #34a853; } /* Attribute value */
        .elements-view code span.comment { color: var(--text-tertiary); font-style: italic; }

        /* DevTools Network (Simulated) */
        .network-log {
            list-style: none;
            flex-grow: 1; /* Take available space */
            overflow-y: auto; /* Scroll within the log */
            padding: 0; margin: 0; /* Reset list styles */
        }
        .network-item {
            display: grid; /* Use grid for better alignment */
            grid-template-columns: minmax(100px, 2fr) auto auto 1fr; /* Columns: URL, Type, Status, Time */
            gap: var(--space-m);
            padding: 5px var(--space-xs);
            border-bottom: 1px dotted var(--border-primary);
            align-items: baseline;
            font-size: 11px; /* Smaller font for network */
        }
        .network-item:last-child { border-bottom: none; }

        .network-url {
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
            color: var(--text-primary);
            cursor: help; /* Indicate title attribute */
        }
        .network-type { color: var(--text-tertiary); text-align: right;}
        .network-status { font-weight: bold; text-align: right; }
        .network-status.success { color: #34a853; }
        .network-status.error { color: var(--accent-error); }
        .network-status.pending { color: var(--accent-primary); }
        .network-status.cancelled { color: var(--text-tertiary); font-style: italic; }
        .network-time { color: var(--text-tertiary); text-align: right; }

        /* DevTools Application (Storage) */
        .storage-view { /* Wrapper for scrolling */
            flex-grow: 1;
            overflow-y: auto;
            padding-right: var(--space-xs); /* Space for scrollbar */
        }
        .storage-section { margin-bottom: var(--space-xl); }

        .storage-title {
            font-weight: 500;
            font-size: 14px;
            margin-bottom: var(--space-s);
            border-bottom: 1px solid var(--border-primary);
            padding-bottom: var(--space-xs);
            position: sticky; /* Keep title visible */
            top: -8px; /* Adjust based on padding */
            background-color: var(--devtools-bg); /* Prevent text overlap */
            z-index: 2;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .storage-actions { /* Now part of the title bar */
             flex-shrink: 0;
        }
        .storage-actions .nexus-button {
             padding: 2px 6px; /* Smaller button */
             font-size: 11px;
        }

        .storage-table-wrapper {
            overflow-x: auto; /* Horizontal scroll if needed */
            max-width: 100%;
            border: 1px solid var(--border-primary);
            border-radius: var(--border-radius-small);
        }
        .storage-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed; /* Helps with overflow */
        }
        .storage-table th, .storage-table td {
            padding: var(--space-xs) var(--space-s);
            text-align: left;
            border-bottom: 1px solid var(--border-primary);
            border-right: 1px solid var(--border-primary);
            font-size: 11px;
            overflow: hidden; /* Apply overflow to cells */
            text-overflow: ellipsis;
            white-space: nowrap;
            vertical-align: top; /* Align content top */
        }
        .storage-table th:last-child, .storage-table td:last-child { border-right: none; }
        .storage-table tr:last-child td { border-bottom: none; }

        .storage-table thead {
            position: sticky; /* Sticky header row */
            top: 28px; /* Below the sticky title */
            z-index: 1;
        }
        .storage-table th {
            background-color: var(--bg-secondary);
            font-weight: 500;
        }
        /* Define column widths */
        .storage-table th:nth-child(1) { width: 35%; } /* URL/Key */
        .storage-table th:nth-child(2) { width: 35%; } /* Title/Value */
        .storage-table th:nth-child(3) { width: 30%; } /* Timestamp/Actions */

        /* --- Utility Classes --- */
        .hidden { display: none !important; }
        .visually-hidden {
            position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px;
            overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0;
        }

        /* Toast Notification Styling */
        .nexus-toast {
            position: fixed;
            bottom: var(--space-l);
            right: var(--space-l);
            padding: var(--space-m) var(--space-l);
            border-radius: var(--border-radius-medium);
            color: var(--text-on-accent);
            background-color: var(--accent-primary); /* Default info */
            z-index: var(--z-toast);
            opacity: 0;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            transform: translateY(20px);
            font-size: 14px;
            box-shadow: 0 4px 15px var(--shadow-color);
        }
        .nexus-toast.visible {
             opacity: 1;
             transform: translateY(0);
        }
        .nexus-toast.nexus-toast-info { background-color: var(--accent-primary); }
        .nexus-toast.nexus-toast-warn { background-color: #fbbc04; color: #202124; } /* Yellow */
        html[theme="dark"] .nexus-toast.nexus-toast-warn { background-color: #fdd663; }
        .nexus-toast.nexus-toast-error { background-color: var(--accent-error); }

    </style>
</head>
<body>
    <div class="nexus-browser-app" id="nexus-browser-app">

        <header class="browser-header">
            <div class="tab-bar" id="tab-bar">
                <!-- Tabs will be inserted here by JS -->
                <button class="nexus-button icon-only add-tab-button" id="add-tab-button" title="New Tab" aria-label="New Tab">
                    <span class="material-symbols-rounded">add</span>
                </button>
            </div>
            <div class="toolbar" id="toolbar">
                <div class="toolbar-group">
                    <button class="nexus-button icon-only" id="back-button" title="Back" aria-label="Back" disabled><span class="material-symbols-rounded">arrow_back</span></button>
                    <button class="nexus-button icon-only" id="forward-button" title="Forward" aria-label="Forward" disabled><span class="material-symbols-rounded">arrow_forward</span></button>
                    <button class="nexus-button icon-only" id="reload-button" title="Reload" aria-label="Reload"><span class="material-symbols-rounded">refresh</span></button>
                    <button class="nexus-button icon-only" id="stop-button" title="Stop" aria-label="Stop" disabled style="display: none;"><span class="material-symbols-rounded">close</span></button>
                    <button class="nexus-button icon-only" id="home-button" title="Home" aria-label="Home"><span class="material-symbols-rounded">home</span></button>
                </div>
                <div class="address-bar-container">
                    <span class="material-symbols-rounded address-bar-icon" id="address-bar-secure-icon" title="Connection security">lock</span>
                    <input type="text" class="address-bar-input" id="address-bar-input" placeholder="Enter address, search, or command..." autocomplete="off" spellcheck="false" aria-label="Address and search bar">
                     <!-- Address suggestions div moved outside container for positioning -->
                    <button class="nexus-button icon-only" id="bookmark-button" title="Bookmark this page" aria-label="Bookmark this page" disabled>
                        <span class="material-symbols-rounded">star_outline</span><!-- Change to 'star' when bookmarked -->
                    </button>
                    <button class="nexus-button icon-only" id="ai-assist-button" title="AI Assist" aria-label="AI Assist">
                        <span class="material-symbols-rounded">smart_toy</span>
                    </button>
                </div>
                <div class="address-suggestions" id="address-suggestions">
                    <!-- Suggestions populated by JS -->
                </div>
                <div class="toolbar-group">
                    <button class="nexus-button icon-only" id="history-button" title="History" aria-label="History"><span class="material-symbols-rounded">history</span></button>
                    <button class="nexus-button icon-only" id="bookmarks-button" title="Bookmarks" aria-label="Bookmarks"><span class="material-symbols-rounded">bookmarks</span></button>
                    <button class="nexus-button icon-only" id="settings-button" title="Settings" aria-label="Settings"><span class="material-symbols-rounded">settings</span></button>
                </div>
                 <div class="progress-bar" id="progress-bar"></div>
            </div>
        </header>

        <main class="browser-main-content">
            <div class="content-area" id="content-area">
                <!-- IFrames will be inserted here by JS -->
                <div class="loading-overlay" id="loading-overlay">
                    <div class="spinner"></div>
                    <div class="loading-message" id="loading-message">Initializing Nexus...</div>
                    <div class="loading-subtext" id="loading-subtext">Please wait</div>
                </div>
            </div>

            <!-- DevTools Panel -->
            <div class="devtools-panel" id="devtools-panel" style="display: none;">
                <div class="devtools-toolbar">
                    <button class="devtools-tab active" data-pane="console">Console</button>
                    <button class="devtools-tab" data-pane="elements">Elements</button>
                    <button class="devtools-tab" data-pane="network">Network</button>
                    <button class="devtools-tab" data-pane="application">Application</button>
                    <!-- Spacer -->
                    <button class="nexus-button icon-only" id="devtools-close-button" title="Close DevTools" aria-label="Close Developer Tools">
                        <span class="material-symbols-rounded">close</span>
                    </button>
                </div>
                <div class="devtools-content">
                    <!-- Console Pane -->
                    <div class="devtools-pane active" id="devtools-console-pane" data-pane="console">
                        <div class="console-output" id="console-output" aria-live="polite"></div>
                        <div class="console-input-container">
                            <span class="material-symbols-rounded">chevron_right</span>
                            <input type="text" class="console-input" id="console-input" placeholder="Execute command in iframe context..." aria-label="Console input">
                        </div>
                    </div>
                    <!-- Elements Pane -->
                    <div class="devtools-pane" id="devtools-elements-pane" data-pane="elements">
                        <pre class="elements-view" id="elements-view" aria-label="Page element source code"><code><!-- Element source code will appear here --></code></pre>
                    </div>
                    <!-- Network Pane -->
                    <div class="devtools-pane" id="devtools-network-pane" data-pane="network">
                        <ul class="network-log" id="network-log" aria-live="polite">
                            <!-- Network items added by JS -->
                        </ul>
                    </div>
                    <!-- Application Pane -->
                    <div class="devtools-pane" id="devtools-application-pane" data-pane="application">
                         <div class="storage-view">
                            <div class="storage-section">
                                <h3 class="storage-title">
                                    <span>History (IndexedDB)</span>
                                    <div class="storage-actions">
                                        <button class="nexus-button" id="clear-history-storage">Clear History</button>
                                    </div>
                                </h3>
                                <div class="storage-table-wrapper">
                                    <table class="storage-table">
                                        <thead><tr><th>URL</th><th>Title</th><th>Timestamp</th></tr></thead>
                                        <tbody id="history-storage-table"></tbody>
                                    </table>
                                </div>
                            </div>
                            <div class="storage-section">
                                 <h3 class="storage-title">
                                     <span>Bookmarks (IndexedDB)</span>
                                     <div class="storage-actions">
                                         <button class="nexus-button" id="clear-bookmarks-storage">Clear Bookmarks</button>
                                     </div>
                                 </h3>
                                <div class="storage-table-wrapper">
                                    <table class="storage-table">
                                        <thead><tr><th>URL</th><th>Title</th><th>Timestamp</th></tr></thead>
                                        <tbody id="bookmarks-storage-table"></tbody>
                                    </table>
                                </div>
                            </div>
                            <!-- Add Settings/localStorage view if needed -->
                         </div>
                    </div>
                </div>
            </div>
        </main>

        <footer class="status-bar" id="status-bar">
            <div class="status-panel" id="status-panel">Ready</div>
            <div class="status-icons">
                <span class="material-symbols-rounded" id="security-status-icon" title="Connection status">lock</span>
                <span class="material-symbols-rounded" id="devtools-status-icon" title="Toggle DevTools (F12)">terminal</span>
            </div>
        </footer>

        <!-- Dialogs for History, Bookmarks, Settings, AI Assist -->
        <dialog class="overlay-panel" id="history-dialog">
            <div class="panel-header">
                <h2 class="panel-title">History</h2>
                <button class="nexus-button icon-only" onclick="this.closest('dialog').close()" aria-label="Close history panel">
                    <span class="material-symbols-rounded">close</span>
                </button>
            </div>
            <div class="panel-content">
                <ul class="panel-list" id="history-list"></ul>
            </div>
            <div class="panel-footer">
                <button class="nexus-button" id="clear-history-button">Clear Browsing Data</button>
            </div>
        </dialog>

        <dialog class="overlay-panel" id="bookmarks-dialog">
            <div class="panel-header">
                <h2 class="panel-title">Bookmarks</h2>
                <button class="nexus-button icon-only" onclick="this.closest('dialog').close()" aria-label="Close bookmarks panel">
                    <span class="material-symbols-rounded">close</span>
                </button>
            </div>
            <div class="panel-content">
                <ul class="panel-list" id="bookmarks-list"></ul>
            </div>
            <div class="panel-footer">
                <button class="nexus-button" id="add-bookmark-dialog-button">Bookmark Current Page</button>
            </div>
        </dialog>

        <dialog class="overlay-panel" id="settings-dialog">
            <div class="panel-header">
                <h2 class="panel-title">Settings</h2>
                <button class="nexus-button icon-only" onclick="this.closest('dialog').close()" aria-label="Close settings panel">
                    <span class="material-symbols-rounded">close</span>
                </button>
            </div>
            <div class="panel-content" id="settings-content">
                <label for="theme-select">Theme:</label>
                <select id="theme-select" class="nexus-input">
                    <option value="dark">Dark</option>
                    <option value="light">Light</option>
                    <option value="system">System</option>
                </select>

                <label for="homepage-url">Homepage URL:</label>
                <input type="text" id="homepage-url" class="nexus-input" placeholder="e.g., future:newtab or https://...">

                <label for="search-template">Search Template URL (%s = query):</label>
                <input type="text" id="search-template" class="nexus-input" placeholder="e.g., https://duckduckgo.com/?q=%s">

                <label for="ai-api-key">AI Service API Key (Optional):</label>
                <input type="password" id="ai-api-key" class="nexus-input" placeholder="Enter your API key (simulation only)">
                <small>Stored locally in IndexedDB. Not sent anywhere in this simulation. Required for potential future real AI integration.</small>

            </div>
            <div class="panel-footer">
                <button class="nexus-button" id="save-settings-button">Save Settings</button>
            </div>
        </dialog>

        <dialog class="overlay-panel" id="ai-assist-dialog">
             <div class="panel-header">
                <h2 class="panel-title">AI Assist</h2>
                <button class="nexus-button icon-only" onclick="this.closest('dialog').close()" aria-label="Close AI Assist panel">
                    <span class="material-symbols-rounded">close</span>
                </button>
            </div>
            <div class="panel-content" id="ai-assist-content">
                 <p>Use AI to interact with page content (simulation).</p>
                <textarea id="ai-assist-output" class="nexus-input" rows="10" readonly style="width: 100%; margin-top: var(--space-m); font-family: var(--font-monospace); font-size: 12px;" aria-label="AI Assist output"></textarea>
            </div>
            <div class="panel-footer">
                <button class="nexus-button" id="ai-summarize-button">Summarize Page</button>
                <button class="nexus-button" id="ai-explain-button">Explain Selection</button>
            </div>
        </dialog>

    </div>

    <script>
        // --- Polyfills/Dependencies (Minimal) ---

        // Basic Sanitizer (WARNING: NOT PRODUCTION SAFE - DOES NOT PREVENT ALL XSS)
        // In a real application, use a robust library like DOMPurify.
        const basicSanitizer = {
            sanitize: (html) => {
                if (typeof html !== 'string') html = String(html);
                // VERY basic - removes inline script tags, javascript: URLs, and common onerror/onload attributes.
                // This is NOT exhaustive and can be bypassed. It's a placeholder.
                const SCRIPT_REGEX = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;
                const JS_URL_REGEX = /href=["']?javascript:/gi;
                const ON_EVENT_REGEX = /\s(on\w+)\s*=\s*("([^"]*)"|'([^']*)'|[^\s>]+)/gi; // Common event handlers

                // 1. Remove script tags
                let clean = html.replace(SCRIPT_REGEX, '');
                // 2. Neutralize javascript: URLs
                clean = clean.replace(JS_URL_REGEX, 'href="#sanitized-js-url"');
                // 3. Remove common on... event handlers
                clean = clean.replace(ON_EVENT_REGEX, '');

                // Add more rules here if needed, but it quickly becomes complex and insufficient.
                // For this simulation, it provides a *minimal* barrier.
                return clean;
            }
        };
        // Use DOMPurify if available in the window scope (e.g., via CDN), otherwise use the basic one.
        const Sanitizer = window.DOMPurify || basicSanitizer;
        if (Sanitizer === basicSanitizer) {
            console.warn("Using basic HTML sanitizer. WARNING: This is NOT secure for untrusted content. Use DOMPurify in production.");
        }

        // --- Utility Functions ---
        const Utils = {
            createElement: (tag, classes = [], attrs = {}, text = '') => {
                const el = document.createElement(tag);
                if (classes.length) el.classList.add(...classes.filter(c => c)); // Filter out falsy class names
                Object.entries(attrs).forEach(([key, value]) => {
                    if (value !== null && value !== undefined) el.setAttribute(key, value);
                });
                if (text) el.textContent = text;
                return el;
            },

            generateId: (prefix = 'id_') => `${prefix}${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 7)}`,

            debounce: (func, wait) => {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func.apply(this, args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },

            isValidURL: (str) => {
                if (!str || typeof str !== 'string') return [false, str];
                let trimmed = str.trim();
                if (trimmed.includes(' ') || trimmed.includes('\n') || trimmed.length > 2048) return [false, trimmed];

                // Allow internal protocol
                if (trimmed.startsWith(Config.INTERNAL_PROTOCOL)) return [true, trimmed];

                // Allow common special URLs
                if (trimmed.startsWith('about:') || trimmed.startsWith('blob:') || trimmed.startsWith('data:')) {
                     try { new URL(trimmed); return [true, trimmed]; } catch (_) { return [false, str]; } // Basic check
                }

                // Prepend https:// if scheme is missing and it looks like a domain
                if (!/^[a-z][a-z0-9+.-]*:/i.test(trimmed) && trimmed.includes('.') && !trimmed.startsWith('/') && !trimmed.startsWith('#')) {
                     // Simple check: contains a dot, doesn't start with common non-URL chars
                    const likelyDomain = /^[a-z0-9-]+(\.[a-z0-9-]+)+/i.test(trimmed.split('/')[0].split('?')[0].split('#')[0]);
                    if (likelyDomain) {
                        trimmed = 'https://' + trimmed;
                    }
                }

                try {
                    const url = new URL(trimmed);
                    // Check for valid http/https/ftp/file protocols primarily
                    if (!['http:', 'https:', 'ftp:', 'file:'].includes(url.protocol)) {
                         // Allow blob/data if they passed the initial check
                         if (!['blob:', 'data:'].includes(url.protocol)) {
                             return [false, str]; // Reject other unknown protocols
                         }
                    }
                    return [true, trimmed]; // URL is valid and normalized (protocol added if needed)
                } catch (_) {
                    return [false, str]; // Invalid URL
                }
            },

            escapeHtml: (unsafe) => {
                 if (unsafe === null || unsafe === undefined) return '';
                 return String(unsafe)
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            },

            truncate: (str, maxLength) => {
                 if (!str || typeof str !== 'string') return '';
                 return str.length > maxLength ? str.substring(0, maxLength - 1) + '…' : str;
            },

             // Simple function to format bytes
            formatBytes: (bytes, decimals = 2) => {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            },
        };

        // --- Simple Event Bus ---
        const EventBus = {
            events: {},
            subscribe(event, callback) {
                if (!this.events[event]) this.events[event] = [];
                this.events[event].push(callback);
                // console.log(`[EventBus] Subscribed to ${event}`);
            },
            publish(event, data) {
                if (!this.events[event]) return;
                // console.log(`[EventBus] Publishing ${event}`, data);
                this.events[event].forEach(callback => {
                    try {
                        callback(data);
                    } catch (error) {
                        console.error(`[EventBus] Error in subscriber for ${event}:`, error);
                    }
                });
            },
            unsubscribe(event, callback) {
                if (!this.events[event]) return;
                this.events[event] = this.events[event].filter(cb => cb !== callback);
                // console.log(`[EventBus] Unsubscribed from ${event}`);
            }
        };

        // --- Configuration ---
        const Config = {
            DB_NAME: 'NexusBrowserDB_v1', // Added version to name
            DB_VERSION: 1,
            STORE_HISTORY: 'history',
            STORE_BOOKMARKS: 'bookmarks',
            STORE_SETTINGS: 'settings',
            DEFAULT_HOMEPAGE: 'future:newtab',
            DEFAULT_SEARCH_TEMPLATE: 'https://duckduckgo.com/?q=%s', // Privacy-focused default
            MAX_TABS: 20,
            MAX_HISTORY_ITEMS: 500, // Max items to KEEP
            MAX_BOOKMARK_ITEMS: 1000,
            SUGGESTION_LIMIT: 6,
            LOADING_TIMEOUT: 30000, // 30 seconds for AI/network simulation
            AI_SERVICE_URL: null, // Not used in this simulation
            AI_API_KEY_SETTING: 'aiApiKey',
            DEFAULT_FAVICON: 'data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🌐</text></svg>',
            INTERNAL_PROTOCOL: 'future:',
            DEVTOOLS_INITIAL_HEIGHT: '300px',
        };

        // --- Storage Manager (IndexedDB Wrapper) ---
        class StorageManager {
            constructor(dbName, dbVersion) {
                this.dbName = dbName;
                this.dbVersion = dbVersion;
                this.db = null;
                this._openingPromise = null; // Prevent race conditions on open
            }

            async openDB() {
                if (this.db) {
                    return this.db;
                }
                if (this._openingPromise) {
                    return this._openingPromise; // Return existing promise if already opening
                }

                this._openingPromise = new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);

                    request.onerror = (event) => {
                        console.error(`IndexedDB error opening ${this.dbName}:`, event.target.error);
                        this._openingPromise = null; // Reset promise on error
                        reject(`IndexedDB error: ${event.target.error}`);
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        console.log(`IndexedDB ${this.dbName} opened successfully.`);
                        this.db.onerror = (errorEvent) => {
                            // Generic error handler for the connection
                            console.error("Database error:", errorEvent.target.error);
                        };
                        this._openingPromise = null; // Reset promise on success
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        console.log(`Upgrading IndexedDB ${this.dbName} to version ${this.dbVersion}`);
                        const db = event.target.result;
                        const transaction = event.target.transaction; // Use provided transaction

                        if (!db.objectStoreNames.contains(Config.STORE_HISTORY)) {
                            const historyStore = db.createObjectStore(Config.STORE_HISTORY, { keyPath: 'id', autoIncrement: true });
                            historyStore.createIndex('url', 'url', { unique: false });
                            historyStore.createIndex('timestamp', 'timestamp', { unique: false });
                            console.log(`Created store: ${Config.STORE_HISTORY}`);
                        }
                        if (!db.objectStoreNames.contains(Config.STORE_BOOKMARKS)) {
                            const bookmarkStore = db.createObjectStore(Config.STORE_BOOKMARKS, { keyPath: 'id', autoIncrement: true });
                            bookmarkStore.createIndex('url', 'url', { unique: true }); // URL must be unique for bookmarks
                            bookmarkStore.createIndex('timestamp', 'timestamp', { unique: false });
                            console.log(`Created store: ${Config.STORE_BOOKMARKS}`);
                        }
                        if (!db.objectStoreNames.contains(Config.STORE_SETTINGS)) {
                            const settingsStore = db.createObjectStore(Config.STORE_SETTINGS, { keyPath: 'key' });
                            // Pre-populate default settings if store is new
                             transaction.objectStore(Config.STORE_SETTINGS).put({ key: 'theme', value: 'dark' });
                             transaction.objectStore(Config.STORE_SETTINGS).put({ key: 'homepage', value: Config.DEFAULT_HOMEPAGE });
                             transaction.objectStore(Config.STORE_SETTINGS).put({ key: 'searchTemplate', value: Config.DEFAULT_SEARCH_TEMPLATE });
                             transaction.objectStore(Config.STORE_SETTINGS).put({ key: Config.AI_API_KEY_SETTING, value: '' });
                            console.log(`Created store: ${Config.STORE_SETTINGS} and populated defaults.`);
                        }
                    };
                });
                return this._openingPromise;
            }

            async performTransaction(storeName, mode, action) {
                const db = await this.openDB();
                return new Promise((resolve, reject) => {
                    let transaction;
                    try {
                        transaction = db.transaction(storeName, mode);
                    } catch (err) {
                         console.error(`Failed to start transaction on ${storeName} with mode ${mode}:`, err);
                        return reject(err);
                    }
                    const store = transaction.objectStore(storeName);
                    let request;

                    transaction.oncomplete = () => {
                        // Resolve only when the transaction is fully complete
                        // The request's onsuccess below resolves with the *result* of the request
                    };
                    transaction.onerror = (event) => {
                        console.error(`Transaction error on ${storeName}:`, event.target.error);
                        reject(event.target.error);
                    };
                    transaction.onabort = (event) => {
                         console.warn(`Transaction aborted on ${storeName}:`, event.target.error);
                         reject(new Error(`Transaction aborted: ${event.target.error}`));
                     };

                    try {
                        request = action(store);
                        if (!request || typeof request.onsuccess === 'undefined') {
                            // Handle actions that don't return a request (like clear)
                            // The transaction's oncomplete will handle successful completion
                            // Resolve immediately for non-request actions? No, wait for tx.oncomplete implicitly
                            resolve(undefined); // Resolve promise for the action itself
                            return;
                        }
                        request.onsuccess = (event) => resolve(event.target.result); // Result of the specific action
                        request.onerror = (event) => {
                             console.error(`Request error in ${storeName}:`, event.target.error);
                            reject(event.target.error); // Reject the promise from performTransaction
                        };
                    } catch (err) {
                        console.error(`Error performing action in transaction on ${storeName}:`, err);
                        reject(err);
                        transaction.abort(); // Abort transaction on error
                    }
                });
            }

            async addItem(storeName, item) {
                // Ensure IndexedDB can handle the item (no functions, etc.)
                const cleanItem = JSON.parse(JSON.stringify(item));
                return this.performTransaction(storeName, 'readwrite', store => store.add(cleanItem));
            }

            async getItem(storeName, key) {
                return this.performTransaction(storeName, 'readonly', store => store.get(key));
            }

            async getAllItems(storeName, indexName = null, sortKey = null, direction = 'next', limit = null) {
                const db = await this.openDB();
                return new Promise((resolve, reject) => {
                    let transaction;
                    try {
                        transaction = db.transaction(storeName, 'readonly');
                    } catch (err) { return reject(err); }
                    const store = transaction.objectStore(storeName);
                    const source = indexName ? store.index(indexName) : store;
                    // Use getAll if no limit or complex cursor logic needed, potentially faster
                    if (!limit && !sortKey && direction === 'next') {
                         const request = source.getAll();
                         request.onsuccess = (event) => resolve(event.target.result);
                         request.onerror = (event) => reject(event.target.error);
                    } else {
                        // Use cursor for sorting/limiting/direction
                        const request = source.openCursor(null, direction);
                        const results = [];
                        let count = 0;

                        request.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor) {
                                results.push(cursor.value);
                                count++;
                                if (!limit || count < limit) {
                                    cursor.continue();
                                } else {
                                    resolve(results); // Limit reached
                                }
                            } else {
                                resolve(results); // No more entries
                            }
                        };
                        request.onerror = (event) => reject(event.target.error);
                    }
                     transaction.onerror = (event) => reject(event.target.error); // Catch tx errors too
                });
            }

             async updateItem(storeName, item) {
                // Ensure IndexedDB can handle the item
                 const cleanItem = JSON.parse(JSON.stringify(item));
                return this.performTransaction(storeName, 'readwrite', store => store.put(cleanItem));
             }

            async deleteItem(storeName, key) {
                return this.performTransaction(storeName, 'readwrite', store => store.delete(key));
            }

            async clearStore(storeName) {
                return this.performTransaction(storeName, 'readwrite', store => store.clear());
            }

            async getSetting(key, defaultValue = null) {
                try {
                    const setting = await this.getItem(Config.STORE_SETTINGS, key);
                    return setting ? setting.value : defaultValue;
                } catch (error) {
                    console.error(`Error getting setting ${key}:`, error);
                    return defaultValue;
                }
            }

            async setSetting(key, value) {
                try {
                    // Ensure value is serializable
                     const cleanValue = JSON.parse(JSON.stringify(value));
                    await this.updateItem(Config.STORE_SETTINGS, { key, value: cleanValue });
                } catch (error) {
                    console.error(`Error setting setting ${key}:`, error);
                }
            }

            async getAllSettings() {
                 try {
                    const settingsArray = await this.getAllItems(Config.STORE_SETTINGS);
                    const settingsObj = {};
                    settingsArray.forEach(item => { settingsObj[item.key] = item.value; });
                    return settingsObj;
                 } catch (error) {
                     console.error("Error getting all settings:", error);
                     return {};
                 }
            }
        }


        // --- AI Core Service (Interface/Mock Simulation) ---
        // Simulates generating futuristic HTML content without calling a real AI API.
        class AICoreService {
            constructor(apiKey) {
                // API Key is stored but not used in this mock implementation.
                this.apiKey = apiKey;
                console.log("AI Core Service Initialized (Simulation Mode).", this.apiKey ? "API Key provided (not used)." : "No API Key.");
            }

             // Main generation function (MOCK)
            async generateContent(prompt, modelName = "simulated-nexus-1.0") {
                 console.log(`[AICore Sim] Generating content... Prompt starts:`, Utils.truncate(prompt, 150));
                 const startTime = Date.now();
                 const networkLog = { url: `AI Generation (${modelName})`, status: 'pending', type: 'ai', startTime };
                 EventBus.publish('network-request', networkLog);

                // --- SIMULATED AI RESPONSE ---
                 return new Promise(async (resolve, reject) => {
                    // Simulate network delay
                     await new Promise(res => setTimeout(res, 500 + Math.random() * 1500));

                     let mockHtml = '';
                     let success = true;
                     let errorMessage = '';
                     const theme = document.documentElement.getAttribute('theme') || 'dark';
                     const isDark = theme === 'dark';

                     // Determine request type based on prompt structure
                     if (prompt.includes("futuristic website themed around")) {
                         const topicMatch = prompt.match(/themed around "([^"]+)"/);
                         const urlMatch = prompt.match(/URL: (.*?)\)/);
                         const topic = topicMatch ? Utils.escapeHtml(topicMatch[1]) : 'Future Topic';
                         const sourceUrl = urlMatch ? Utils.escapeHtml(urlMatch[1]) : 'unknown_source';

                         mockHtml = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>${topic} - Nexus Portal</title>
    <style>
        :root {
             --sim-bg: ${isDark ? '#1a1b1e' : '#f8f9fa'};
             --sim-text: ${isDark ? '#e8eaed' : '#202124'};
             --sim-accent: ${isDark ? '#8ab4f8' : '#1a73e8'};
             --sim-border: ${isDark ? '#3c4043' : '#dadce0'};
             --sim-secondary-text: ${isDark ? '#9aa0a6' : '#5f6368'};
        }
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(145deg, ${isDark ? '#23252b' : '#eef1f5'}, var(--sim-bg));
            color: var(--sim-text);
            padding: 30px;
            margin: 0;
            min-height: 90vh;
            line-height: 1.7;
        }
        h1 {
            color: var(--sim-accent);
            text-shadow: 0 0 10px rgba(${isDark ? '138, 180, 248, 0.3' : '26, 115, 232, 0.3'});
            border-bottom: 1px solid rgba(${isDark ? '138, 180, 248, 0.5' : '26, 115, 232, 0.5'});
            padding-bottom: 10px; margin-bottom: 25px; font-weight: 500;
            font-size: 2.5em; text-align: center;
        }
        .content-pod {
            background: rgba(${isDark ? '255, 255, 255, 0.05' : '0, 0, 0, 0.03'});
            border-radius: 12px; padding: 25px; margin: 20px auto;
            border: 1px solid var(--sim-border);
            box-shadow: 0 6px 20px rgba(0,0,0,${isDark ? '0.25' : '0.08'});
            max-width: 700px; backdrop-filter: blur(3px);
        }
        a { color: var(--sim-accent); text-decoration: none; }
        a:hover { text-decoration: underline; filter: brightness(1.2); }
        img.placeholder-img {
            max-width: 80%; height: auto; display: block; margin: 15px auto;
            border-radius: 8px; opacity: ${isDark ? 0.6 : 0.75}; border: 1px solid var(--sim-border);
            filter: ${isDark ? 'grayscale(30%)' : 'grayscale(10%)'};
        }
        .status-notice {
            font-style: italic; color: var(--sim-secondary-text); font-size: 0.9em;
            border-left: 3px solid var(--sim-accent); padding-left: 10px; margin-top: 15px;
        }
        .status-notice::before { content: '⚙️'; display: inline-block; margin-right: 8px; animation: spin-gear 5s linear infinite; }
        @keyframes spin-gear { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        footer { text-align: center; margin-top: 40px; font-size: 0.85em; color: var(--sim-secondary-text); opacity: 0.7; }
        nav { text-align: center; margin-bottom: 20px; }
        nav a { margin: 0 15px; font-weight: 500; }
    </style>
    <!-- Source URL (for info): ${sourceUrl} -->
</head>
<body>
    <h1>${topic} Nexus Portal</h1>
    <nav>
        <a href="#">Home</a> | <a href="#">Data Streams</a> | <a href="#">Archives</a> | <a href="#">System Link</a>
    </nav>
    <div class="content-pod">
        <h2>Welcome, Observer</h2>
        <p>Accessing primary data node for <strong>${topic}</strong>. Information flows synthesized by Nexus Core AI.</p>
        <p>Current operational status: Optimal. Quantum entanglement matrices stable.</p>
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 50'%3E%3Crect width='100' height='50' fill='%23${isDark ? '333' : 'ddd'}'/%3E%3Ctext x='50' y='30' font-family='monospace' font-size='10' fill='%23${isDark ? '888' : '555'}' text-anchor='middle'%3EFuturistic Graphic%3C/text%3E%3C/svg%3E" alt="Futuristic Placeholder Graphic" class="placeholder-img">
        <p class="status-notice">Nexus routing protocols undergoing automated optimization sequence. Minor data latency possible.</p>
    </div>
    <div class="content-pod">
        <h3>Sub-Node Access</h3>
        <p>Further exploration requires authorization or enhanced query parameters. Available sub-nodes:</p>
        <ul>
             <li><a href="#">Historical Data (${topic})</a></li>
             <li><a href="#">Real-time Analytics Stream</a> (Requires Credentials)</li>
             <li><a href="#">Simulated Future Projections</a></li>
        </ul>
    </div>
    <footer>Nexus Browser 2050 Simulation | Content Generated by AICoreService Mock | &copy; ${new Date().getFullYear() + 29}</footer>
</body>
</html>`;
                     } else if (prompt.includes("simple, futuristic-styled HTML snippet")) {
                         const topicMatch = prompt.match(/prompt "([^"]+)"/);
                         const topic = topicMatch ? Utils.escapeHtml(topicMatch[1]) : 'Requested Data';
                         mockHtml = `
<div style="padding: 18px; border: 1px solid ${isDark ? '#3c4043' : '#dadce0'}; border-left: 4px solid ${isDark ? '#8ab4f8' : '#1a73e8'}; border-radius: 8px; background: rgba(${isDark ? '138, 180, 248, 0.08' : '26, 115, 232, 0.05'}); margin-bottom: 15px; box-shadow: 0 2px 5px rgba(0,0,0,${isDark ? '0.2' : '0.05'});">
    <h3 style="margin: 0 0 8px 0; color: ${isDark ? '#e8eaed' : '#202124'}; font-weight: 500; font-size: 1.1em;">
        <span style="font-size: 1.2em; vertical-align: -2px; margin-right: 6px; color: ${isDark ? '#8ab4f8' : '#1a73e8'};">⚡</span> Data Snippet: ${topic}
    </h3>
    <p style="margin: 0 0 10px 0; color: ${isDark ? '#bdc1c6' : '#5f6368'}; font-size: 0.95em;">
        Minimal data packet generated by Nexus Core based on your query.
    </p>
    <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='none' stroke='%23${isDark ? '9aa0a6' : '80868b'}' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z'/%3E%3C/svg%3E" alt="info icon" style="width: 18px; height: 18px; float: left; margin-right: 8px; opacity: 0.7; vertical-align: middle;">
    <p style="font-size: 0.85em; color: ${isDark ? '#9aa0a6' : '#80868b'}; font-style: italic; margin: 0; clear: left;">
        Consider refining query parameters for enhanced data streams.
    </p>
</div>`;
                     } else if (prompt.includes("Summarize the following text")) {
                          const textToSummarize = prompt.split('\n\n')[1] || '';
                          const wordCount = textToSummarize.split(/\s+/).length;
                         mockHtml = `
<div style="padding: 15px; border: 1px solid ${isDark ? '#3c4043' : '#dadce0'}; border-radius: 6px; background: rgba(${isDark ? '255,255,255,0.04' : '0,0,0,0.02'});">
<strong style="color: ${isDark ? '#8ab4f8' : '#1a73e8'};">Simulated Summary:</strong>
<p style="margin-top: 5px; margin-bottom: 0; color: ${isDark ? '#e8eaed' : '#202124'};">This text (approx. ${wordCount} words) appears to discuss [Simulated Main Topic based on keywords, e.g., 'futuristic design concepts']. Key points likely involve [Simulated Point A, e.g., 'minimalist interfaces'], [Simulated Point B, e.g., 'AI integration'], and potentially [Simulated Point C, e.g., 'data visualization']. The overall tone seems [Simulated Tone, e.g., 'informative and speculative'].</p>
<em style="font-size: 0.8em; color: ${isDark ? '#9aa0a6' : '#5f6368'};"> (Generated by Nexus AI Simulation)</em>
</div>`;
                     } else if (prompt.includes("Explain the following code")) {
                          const codeSnippet = prompt.match(/```([\s\S]*?)```/)?.[1] || '[Code Snippet Missing]';
                          const lineCount = codeSnippet.trim().split('\n').length;
                         mockHtml = `
<div style="padding: 15px; border: 1px solid ${isDark ? '#3c4043' : '#dadce0'}; border-radius: 6px; background: rgba(${isDark ? '255,255,255,0.04' : '0,0,0,0.02'});">
<strong style="color: ${isDark ? '#8ab4f8' : '#1a73e8'};">Simulated Code Explanation:</strong>
<p style="margin-top: 5px; margin-bottom: 5px; color: ${isDark ? '#e8eaed' : '#202124'};">This ${lineCount}-line code snippet seems to be written in [Simulated Language, e.g., 'CSS' or 'JavaScript']. It likely defines [Simulated Purpose, e.g., 'styling for a button component' or 'a function to handle user clicks']. Key elements observed are [Simulated Element, e.g., 'class selectors and color properties' or 'event listeners and DOM manipulation'].</p>
<pre style="background: rgba(0,0,0,0.1); padding: 8px; border-radius: 4px; font-size: 0.85em; max-height: 100px; overflow: auto; border: 1px solid ${isDark ? '#5f6368' : '#cdd0d4'}; color: ${isDark ? '#bdc1c6' : '#3c4043'};"><code>${Utils.escapeHtml(Utils.truncate(codeSnippet.trim(), 300))}</code></pre>
<em style="font-size: 0.8em; color: ${isDark ? '#9aa0a6' : '#5f6368'};"> (Generated by Nexus AI Simulation)</em>
</div>`;
                     }
                      else {
                         // Fallback / Error simulation
                         success = false;
                         errorMessage = 'AI simulation could not interpret the request type from the prompt.';
                         mockHtml = `<h2>Simulation Error</h2><p>Could not process request.</p><p><strong>Reason:</strong> ${errorMessage}</p>`;
                         console.warn("[AICore Sim] Failed to interpret prompt:", prompt);
                     }

                     if (success) {
                        networkLog.status = 'success';
                        networkLog.endTime = Date.now();
                        EventBus.publish('network-request', networkLog);
                        resolve(mockHtml);
                     } else {
                        networkLog.status = 'error';
                        networkLog.error = errorMessage;
                        networkLog.endTime = Date.now();
                         EventBus.publish('network-request', networkLog);
                        reject(new Error(errorMessage));
                     }
                 });
                // --- End SIMULATED AI RESPONSE ---
            }

            // Specific task wrappers (using the mock generateContent)
            async summarizeText(text) {
                 if (!text || text.length < 20) return Promise.resolve("<p><em>Not enough text provided for summarization simulation.</em></p>");
                 // Basic prompt structure for summarization
                const prompt = `Summarize the following text concisely (2-3 sentences):\n\n${Utils.truncate(text, 5000)}`; // Limit input text
                return this.generateContent(prompt, 'simulated-summarizer-1.0');
            }

            async explainCode(codeSnippet) {
                 if (!codeSnippet || codeSnippet.length < 5) return Promise.resolve("<p><em>No code provided for explanation simulation.</em></p>");
                // Basic prompt structure for code explanation
                const prompt = `Explain the following code snippet briefly:\n\n\`\`\`\n${Utils.truncate(codeSnippet, 3000)}\n\`\`\``; // Limit input code
                return this.generateContent(prompt, 'simulated-code-explainer-1.0');
            }
        }

        // --- Tab Class ---
        class Tab {
            constructor(id, manager, initialUrl = null) {
                this.id = id;
                this.manager = manager; // Reference to TabManager
                this.ui = manager.app.uiManager; // Shortcut
                this.title = "New Tab";
                this.url = initialUrl || Config.DEFAULT_HOMEPAGE; // Current URL or internal page
                this.isLoading = false;
                this.isGenerating = false; // AI generation flag (often overlaps with isLoading)
                this.favicon = Config.DEFAULT_FAVICON;
                this.history = []; // Array of { url: string, title: string }
                this.historyIndex = -1;
                this.lastError = null;
                this.iframeBlobUrl = null; // Store blob URL for cleanup
                this.initialLoadDone = false; // Track if the first navigation is done

                // DOM Elements
                this.tabElement = null;
                this.iframeContainer = null;
                this.iframe = null;

                this._createDOMElements();

                // Don't navigate immediately in constructor, let TabManager handle it
                 if (initialUrl && this.manager.activeTabId !== this.id) {
                     // Only set the state if it's not the active tab being created/restored
                     // Active tab navigation is handled by TabManager.init or addTab
                    this.setUrl(initialUrl, false); // Set initial URL state without adding to history yet
                 }
            }

            _createDOMElements() {
                // Iframe container and iframe
                this.iframeContainer = Utils.createElement('div', ['iframe-container'], { 'data-tab-id': this.id });
                this.iframe = Utils.createElement('iframe', ['nexus-iframe'], {
                    title: 'Browser Content Area',
                    name: `nexusFrame-${this.id}`,
                    // Security: Sandbox is crucial. Adjust as needed, but be restrictive.
                    // 'allow-scripts' needed for DevTools communication script.
                    // 'allow-same-origin' needed for blob: URLs to work correctly with postMessage back to parent.
                    // 'allow-forms' if forms should work.
                    // 'allow-popups' potentially needed, but risky.
                    // 'allow-downloads' if generated content might trigger downloads.
                    sandbox: "allow-scripts allow-same-origin allow-forms allow-popups allow-downloads allow-modals",
                    // Feature policy (Permissions Policy) - Restrict sensitive APIs aggressively
                    allow: "accelerometer 'none'; ambient-light-sensor 'none'; autoplay 'none'; battery 'none'; camera 'none'; cross-origin-isolated 'none'; display-capture 'none'; document-domain 'none'; encrypted-media 'none'; execution-while-not-rendered 'none'; execution-while-out-of-viewport 'none'; fullscreen *; geolocation 'none'; gyroscope 'none'; keyboard-map 'none'; magnetometer 'none'; microphone 'none'; midi 'none'; navigation-override 'none'; payment 'none'; picture-in-picture 'none'; publickey-credentials-get 'none'; screen-wake-lock 'none'; sync-xhr 'none'; usb 'none'; web-share 'none'; xr-spatial-tracking 'none'"
                });

                this.iframe.src = 'about:blank'; // Initial blank page prevents premature load events

                 // Add error handler directly on the iframe element
                 this.iframe.addEventListener('error', (event) => {
                     console.error(`Iframe loading error for tab ${this.id}:`, event);
                     // This might catch issues before the content script runs
                     this.handleLoadError(new Error("Iframe content failed to load at the element level."));
                 });


                this.iframeContainer.appendChild(this.iframe);
                this.ui.dom.contentArea.appendChild(this.iframeContainer);

                // Tab element in the tab bar
                this.tabElement = Utils.createElement('div', ['tab-item'], { 'data-tab-id': this.id, title: this.title });
                const faviconEl = Utils.createElement('div', ['tab-favicon']);
                faviconEl.style.backgroundImage = `url('${this.favicon}')`;
                const titleEl = Utils.createElement('span', ['tab-title'], {}, this.title);
                const closeBtn = Utils.createElement('button', ['nexus-button', 'icon-only', 'tab-close-button'], { title: 'Close Tab', 'aria-label': 'Close Tab' });
                closeBtn.innerHTML = '<span class="material-symbols-rounded">close</span>';

                this.tabElement.append(faviconEl, titleEl, closeBtn);

                // Event Listeners for Tab Element
                this.tabElement.addEventListener('click', (e) => {
                    if (!e.target.closest('.tab-close-button')) {
                        this.manager.switchToTab(this.id);
                    }
                });
                 // Middle mouse button click to close tab
                this.tabElement.addEventListener('mousedown', (e) => {
                    if (e.button === 1 && !e.target.closest('.tab-close-button')) {
                        e.preventDefault(); // Prevent default middle-click actions (like autoscroll)
                        this.manager.closeTab(this.id);
                    }
                });
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent tab selection
                    this.manager.closeTab(this.id);
                });
            }

            setTitle(newTitle) {
                const cleanTitle = newTitle ? Utils.truncate(String(newTitle), 60) : "Untitled";
                this.title = cleanTitle;
                const titleEl = this.tabElement?.querySelector('.tab-title');
                if (titleEl) titleEl.textContent = this.title;
                if (this.tabElement) this.tabElement.title = newTitle || "Untitled"; // Full title on hover

                if (this.manager.activeTabId === this.id) {
                    EventBus.publish('active-tab-title-changed', this.title);
                }

                // Update history entry title if navigating through history
                if (this.history.length > 0 && this.historyIndex >= 0 && this.history[this.historyIndex]) {
                     // Only update if the URL matches, otherwise it might be a new page load title
                     if(this.history[this.historyIndex].url === this.url) {
                         this.history[this.historyIndex].title = this.title;
                     }
                }
            }

            setUrl(newUrl, updateAddressBar = true) {
                 const finalUrl = newUrl || 'about:blank';
                 if (this.url === finalUrl && this.initialLoadDone) return; // Avoid redundant sets

                this.url = finalUrl;
                if (updateAddressBar && this.manager.activeTabId === this.id) {
                    this.ui.setAddressBarValue(this.url);
                    this.ui.updateBookmarkStatus(this.url); // Check if new URL is bookmarked
                }
                this.ui.updateSecurityIcon(this.url); // Update lock icon etc.
            }

            setFavicon(newFaviconUrl) {
                 // Basic check for potentially invalid favicons
                 let favUrl = Config.DEFAULT_FAVICON;
                 if (newFaviconUrl && typeof newFaviconUrl === 'string' && newFaviconUrl.length < 2048 && (newFaviconUrl.startsWith('data:') || newFaviconUrl.startsWith('http:') || newFaviconUrl.startsWith('https:') || newFaviconUrl.startsWith('blob:'))) {
                      favUrl = newFaviconUrl;
                 }
                 // TODO: Extract favicon from generated HTML <link rel="icon"> tag?
                 // For now, we only set the default.

                this.favicon = favUrl;
                const faviconEl = this.tabElement?.querySelector('.tab-favicon');
                if (faviconEl) faviconEl.style.backgroundImage = `url('${this.favicon}')`;
            }

            setIsLoading(loading, message = '', subtext = '') {
                this.isLoading = loading;
                 // Link isGenerating flag for simplicity, ContentRenderer manages specifics
                this.isGenerating = loading && (subtext.includes('Generating') || message.includes('Processing'));

                if (this.tabElement) {
                    this.tabElement.classList.toggle('loading', loading); // Add visual indicator?
                }
                if (this.manager.activeTabId === this.id) {
                     // Show specific messages if provided
                    const displayMessage = message || (loading ? "Loading..." : "Ready");
                    const displaySubtext = subtext || (loading ? this.url : "");
                    this.ui.setLoadingState(loading, displayMessage, displaySubtext);
                    this.updateNavState(); // Update button states based on loading
                     this.ui.updateStatus(loading ? displayMessage : (this.lastError ? "Error loading page" : "Ready"));
                }
                 if (!loading) {
                     this.initialLoadDone = true; // Mark that a load attempt finished
                 }
            }

             handleLoadError(error) {
                 console.error(`[Tab ${this.id}] Load Error:`, error);
                 this.lastError = error;
                 this.setIsLoading(false); // Stop loading indicator

                 const errorTitle = "Render Error";
                 const errorHtml = this.manager.app.contentRenderer._createErrorPage(this.url, error.message);
                 this.manager.app.contentRenderer._updateIframe(this, errorHtml, this.url, errorTitle); // Display error page

                 if (this.manager.activeTabId === this.id) {
                     this.ui.updateStatus(`Error: ${error.message}`);
                     this.updateNavState();
                     this.ui.updateBookmarkStatus(this.url); // Update in case URL changed
                 }
                 // Log to network panel
                 EventBus.publish('network-request', {
                     url: this.url, status: 'error', type: 'navigation',
                     error: error.message, startTime: Date.now(), endTime: Date.now()
                 });
             }

            addToHistory(url, title) {
                 // Avoid adding duplicates, blank/internal pages, or rapidly
                 const now = Date.now();
                 if (!url || url === 'about:blank' || url.startsWith(Config.INTERNAL_PROTOCOL)) {
                     return;
                 }
                 const lastEntry = this.history[this.historyIndex];
                 if (lastEntry && lastEntry.url === url) {
                     // If URL is same, just update title if it changed substantially
                     if (title && lastEntry.title !== title) {
                         lastEntry.title = title;
                         // Update global history title as well? Maybe not necessary here.
                     }
                     return;
                 }

                 // If navigating back then forward, trim the future history
                 if (this.historyIndex < this.history.length - 1) {
                     console.log(`[Tab ${this.id}] Trimming forward history from index ${this.historyIndex + 1}`);
                     this.history = this.history.slice(0, this.historyIndex + 1);
                 }

                 const historyEntry = { url, title: title || url, timestamp: now };
                 this.history.push(historyEntry);
                 this.historyIndex++;
                 console.log(`[Tab ${this.id}] Added to history: ${url}, Index: ${this.historyIndex}, Total: ${this.history.length}`);


                 this.updateNavState();

                 // Add to global history via manager (debounced slightly?)
                 this.manager.app.historyManager.addHistoryItem(url, title);
             }

            goBack() {
                if (this.canGoBack()) {
                     this.historyIndex--;
                     const target = this.history[this.historyIndex];
                     console.log(`[Tab ${this.id}] Going back to: ${target.url} (Index ${this.historyIndex})`);
                     // false: don't add to history again (it's already there)
                     this.manager.app.navigateTo(target.url, false, this.id)
                         .then(() => {
                              // Title *should* be updated by the page load/render process
                              // but we can set it from history as a fallback
                              if (this.title !== target.title) {
                                   this.setTitle(target.title);
                              }
                              this.updateNavState();
                         })
                         .catch(err => console.error("Error navigating back:", err));

                }
            }

            goForward() {
                if (this.canGoForward()) {
                     this.historyIndex++;
                     const target = this.history[this.historyIndex];
                     console.log(`[Tab ${this.id}] Going forward to: ${target.url} (Index ${this.historyIndex})`);
                     this.manager.app.navigateTo(target.url, false, this.id)
                         .then(() => {
                             if (this.title !== target.title) {
                                  this.setTitle(target.title);
                             }
                             this.updateNavState();
                         })
                         .catch(err => console.error("Error navigating forward:", err));
                }
            }

            reload(bypassCache = false) { // bypassCache not used in this simulation
                 const currentEntry = this.history[this.historyIndex];
                 let urlToReload = currentEntry?.url || this.url;

                 // Don't reload about:blank or if already loading
                 if (!urlToReload || urlToReload === 'about:blank' || this.isLoading) {
                     console.log(`[Tab ${this.id}] Reload prevented: URL=${urlToReload}, Loading=${this.isLoading}`);
                     return;
                 }

                 console.log(`[Tab ${this.id}] Reloading: ${urlToReload}`);
                 this.lastError = null; // Clear last error on reload attempt
                 // Reload current URL - don't add to history
                 this.manager.app.navigateTo(urlToReload, false, this.id);
            }

            stopLoading() {
                if (this.isLoading || this.isGenerating) {
                     console.log(`[Tab ${this.id}] Stopping load for: ${this.url}`);
                     // Clean up previous blob URL if exists
                     this.revokeBlobUrl();
                     // Set iframe to blank to effectively stop loading/scripts
                     if (this.iframe) this.iframe.src = 'about:blank';

                     this.setIsLoading(false); // Reset loading state
                     this.isGenerating = false;
                     this.lastError = new Error("Loading stopped by user."); // Set specific error

                     if (this.manager.activeTabId === this.id) {
                         this.ui.updateStatus("Stopped");
                         setTimeout(() => this.ui.updateStatus(this.lastError ? "Error" : "Ready"), 1500);
                         this.updateNavState();
                     }

                     // Publish event for DevTools Network log
                     EventBus.publish('network-request', {
                         url: this.url, status: 'cancelled', type: 'navigation', // Or 'generation' if applicable
                         startTime: Date.now(), endTime: Date.now() // Simplified time for cancelled
                     });
                 }
            }

            canGoBack() {
                return this.historyIndex > 0;
            }

            canGoForward() {
                return this.historyIndex < this.history.length - 1;
            }

            updateNavState() {
                if (this.manager.activeTabId === this.id) {
                    this.ui.updateNavigationButtons(this.canGoBack(), this.canGoForward(), this.isLoading);
                }
            }

            activate() {
                 if (!this.iframeContainer || !this.tabElement) {
                     console.error(`[Tab ${this.id}] Cannot activate - DOM elements missing.`);
                     return;
                 }
                this.iframeContainer.classList.add('active');
                this.tabElement.classList.add('active');
                this.tabElement.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' }); // Ensure tab is visible

                this.updateNavState();
                this.ui.setAddressBarValue(this.url);
                this.ui.updateSecurityIcon(this.url);
                this.ui.updateBookmarkStatus(this.url);
                this.setTitle(this.title); // Ensure window title updates

                if (this.isLoading) {
                    this.ui.setLoadingState(true, "Loading...", this.url); // Ensure loading indicator is shown
                } else {
                    this.ui.setLoadingState(false);
                }
                 this.ui.updateStatus(this.isLoading ? "Loading..." : (this.lastError ? `Error: ${this.lastError.message}` : "Ready"));

                // Ensure DevTools reflects the context of this tab
                EventBus.publish('active-tab-changed', this);
            }

            deactivate() {
                 if (!this.iframeContainer || !this.tabElement) return;
                this.iframeContainer.classList.remove('active');
                this.tabElement.classList.remove('active');
            }

            revokeBlobUrl() {
                if (this.iframeBlobUrl) {
                    // console.log(`[Tab ${this.id}] Revoking Blob URL: ${this.iframeBlobUrl}`);
                    try {
                        URL.revokeObjectURL(this.iframeBlobUrl);
                    } catch (e) {
                        console.warn("Failed to revoke Object URL:", this.iframeBlobUrl, e);
                    }
                    this.iframeBlobUrl = null;
                }
            }

            destroy() {
                 console.log(`[Tab ${this.id}] Destroying tab: ${this.url}`);
                 this.stopLoading(); // Ensure loading stops and buttons update
                 this.revokeBlobUrl(); // Clean up blob URL
                 this.tabElement?.remove();
                 this.iframeContainer?.remove();

                 // Release references to prevent memory leaks
                 this.manager = null;
                 this.ui = null;
                 this.tabElement = null;
                 this.iframeContainer = null;
                 this.iframe = null;
                 this.history = [];
                 this.historyIndex = -1;
            }

            // Get state for saving
             getState() {
                 // Only save essential data to avoid excessive storage use
                 return {
                     id: this.id,
                     url: this.url,
                     title: this.title,
                     // Favicon not saved, use default on restore
                     // Save limited history to restore back/forward state, not full history
                     history: this.history.slice(Math.max(0, this.historyIndex - 5), this.historyIndex + 6), // Save ~10 surrounding entries
                     historyIndex: Math.min(5, this.historyIndex), // Adjust index relative to sliced history
                 };
             }

             // Restore state from saved data
             restoreState(state) {
                 this.url = state.url || Config.DEFAULT_HOMEPAGE;
                 this.setTitle(state.title || "Restored Tab");
                 this.setFavicon(Config.DEFAULT_FAVICON); // Always reset favicon

                 this.history = Array.isArray(state.history) ? [...state.history] : [];
                 // Validate restored history index
                 const restoredIndex = (typeof state.historyIndex === 'number') ? state.historyIndex : -1;
                 this.historyIndex = Math.max(-1, Math.min(restoredIndex, this.history.length - 1));

                 console.log(`[Tab ${this.id}] Restored state: URL=${this.url}, History items=${this.history.length}, Index=${this.historyIndex}`);

                 // Don't load content here; TabManager handles loading the active tab after restore
                 // Update URL in address bar only if activated later by TabManager
             }
        }

        // --- Tab Manager ---
        class TabManager {
            constructor(app) {
                this.app = app;
                this.ui = app.uiManager;
                this.storage = app.storage;
                this.tabs = [];
                this.activeTabId = null;
                this._saveStateTimeout = null;
            }

            async init() {
                console.log("[TabManager] Initializing...");
                let restoredActive = false;
                let activeTabNeedsLoad = false;
                let activeTabUrlToLoad = null;

                try {
                    const savedTabsState = await this.storage.getSetting('tabsState', []);
                    const savedActiveTabId = await this.storage.getSetting('activeTabId', null);

                    if (Array.isArray(savedTabsState) && savedTabsState.length > 0) {
                        console.log(`[TabManager] Restoring ${savedTabsState.length} tabs...`);
                        savedTabsState.forEach(state => {
                            if (this.tabs.length >= Config.MAX_TABS) return; // Prevent restoring too many
                            if (!state || !state.id) {
                                console.warn("[TabManager] Skipping invalid saved tab state:", state);
                                return;
                            }
                            const newTab = this.createTabObject(state.id);
                            newTab.restoreState(state);
                            this.tabs.push(newTab);
                            this.ui.addTabElement(newTab.tabElement);
                        });

                        // Validate and set active tab
                        const potentialActiveTab = this.tabs.find(t => t.id === savedActiveTabId);
                        if (potentialActiveTab) {
                            this.activeTabId = savedActiveTabId;
                            restoredActive = true;
                            // Check if the restored active tab's URL should be loaded
                            if (potentialActiveTab.url && potentialActiveTab.url !== 'about:blank') {
                                activeTabNeedsLoad = true;
                                activeTabUrlToLoad = potentialActiveTab.url;
                            }
                             console.log(`[TabManager] Restored active tab: ${this.activeTabId}`);
                        } else if (this.tabs.length > 0) {
                            // If saved active ID is invalid, activate the first restored tab
                            this.activeTabId = this.tabs[0].id;
                             restoredActive = true;
                             activeTabNeedsLoad = this.tabs[0].url && this.tabs[0].url !== 'about:blank';
                             activeTabUrlToLoad = this.tabs[0].url;
                            console.log(`[TabManager] Saved active tab invalid, activating first restored: ${this.activeTabId}`);
                        }
                    }
                } catch (error) {
                    console.error("[TabManager] Error loading saved tab state:", error);
                    // Clear potentially corrupted state
                    await this.storage.setSetting('tabsState', []);
                    await this.storage.setSetting('activeTabId', null);
                }

                // If no tabs were restored or no active tab set, create a new initial tab
                if (this.tabs.length === 0 || !restoredActive) {
                    console.log("[TabManager] No valid saved state or no tabs, creating initial tab.");
                    const initialTab = this.addTab(Config.DEFAULT_HOMEPAGE, true, false); // Add, make active, don't navigate yet
                    activeTabNeedsLoad = true; // New tab always needs load
                    activeTabUrlToLoad = initialTab?.url || Config.DEFAULT_HOMEPAGE;
                }

                 // Activate the designated active tab visually
                 const tabToActivate = this.getActiveTab();
                 if(tabToActivate) {
                     tabToActivate.activate();
                 } else {
                      console.error("[TabManager] Failed to find a tab to activate during initialization.");
                 }

                // Now, navigate the active tab if needed
                if (activeTabNeedsLoad && activeTabUrlToLoad) {
                     console.log(`[TabManager] Loading initial/restored active tab content: ${activeTabUrlToLoad}`);
                    // Use setTimeout to ensure the DOM is fully ready and activation is complete
                    setTimeout(() => {
                        this.app.navigateTo(activeTabUrlToLoad, true, this.activeTabId)
                            .catch(err => console.error(`[TabManager] Error during initial navigation for active tab:`, err));
                    }, 50); // Small delay
                }

                // Set up auto-save on unload
                window.addEventListener('beforeunload', () => this.saveTabsState(true)); // Force immediate save on close
                 console.log("[TabManager] Initialization complete.");
            }

            createTabObject(id = null) {
                const newTabId = id || Utils.generateId('tab_');
                return new Tab(newTabId, this);
            }

            addTab(urlToLoad = null, makeActive = true, navigate = true) {
                if (this.tabs.length >= Config.MAX_TABS) {
                    this.ui.showToast(`Maximum tabs (${Config.MAX_TABS}) reached.`, "warn");
                    return null;
                }

                const newTab = this.createTabObject();
                this.tabs.push(newTab);
                this.ui.addTabElement(newTab.tabElement);
                console.log(`[TabManager] Added tab: ${newTab.id}`);


                if (makeActive || this.tabs.length === 1) {
                    this.switchToTab(newTab.id);
                }

                 // Navigate the new tab (unless explicitly told not to)
                 if (navigate) {
                     const effectiveUrl = urlToLoad || Config.DEFAULT_HOMEPAGE;
                     // Use setTimeout to ensure the tab switch is processed visually first
                     setTimeout(() => {
                           console.log(`[TabManager] Navigating new tab ${newTab.id} to: ${effectiveUrl}`);
                          this.app.navigateTo(effectiveUrl, true, newTab.id)
                               .catch(err => console.error(`[TabManager] Error navigating new tab:`, err));
                      }, 0);
                 }

                this.scheduleSaveState();
                return newTab;
            }

            closeTab(tabId) {
                const tabIndex = this.tabs.findIndex(t => t.id === tabId);
                if (tabIndex === -1) {
                     console.warn(`[TabManager] Attempted to close non-existent tab: ${tabId}`);
                     return;
                }

                const tabToClose = this.tabs[tabIndex];
                 console.log(`[TabManager] Closing tab: ${tabId} (${tabToClose.title})`);
                const wasActive = this.activeTabId === tabId;

                // Destroy tab resources first
                tabToClose.destroy();
                this.tabs.splice(tabIndex, 1);

                if (this.tabs.length === 0) {
                    // If the last tab is closed, add a new default tab
                     console.log("[TabManager] Last tab closed, creating new default tab.");
                    this.addTab(Config.DEFAULT_HOMEPAGE, true); // Creates and activates
                } else if (wasActive) {
                    // If the active tab was closed, switch to an adjacent tab
                    // Prefer the tab to the right, then left, then the first one
                    const switchToIndex = tabIndex < this.tabs.length ? tabIndex : tabIndex - 1;
                    const nextActiveTabId = this.tabs[Math.max(0, switchToIndex)].id;
                     console.log(`[TabManager] Closed active tab, switching to: ${nextActiveTabId}`);
                    this.switchToTab(nextActiveTabId);
                }
                 // Else: closing a background tab doesn't change the active one

                this.scheduleSaveState();
                this.ui.updateStatus("Tab closed");
            }

            switchToTab(tabId) {
                 if (this.activeTabId === tabId) return; // Already active

                 const newActiveTab = this.getTabById(tabId);
                 if (!newActiveTab) {
                     console.warn(`[TabManager] Attempted to switch to non-existent tab: ${tabId}`);
                     return;
                 }

                 console.log(`[TabManager] Switching to tab: ${tabId} (${newActiveTab.title})`);

                 const previousActiveTab = this.getActiveTab();
                 previousActiveTab?.deactivate();

                 this.activeTabId = tabId;
                 newActiveTab.activate(); // Handles its own UI updates

                 this.scheduleSaveState();
             }


            getActiveTab() {
                 if (!this.activeTabId) return null;
                 return this.tabs.find(t => t.id === this.activeTabId);
            }

            getTabById(tabId) {
                return this.tabs.find(t => t.id === tabId);
            }

            // Debounced saving of tab state
            scheduleSaveState() {
                 if (this._saveStateTimeout) {
                     clearTimeout(this._saveStateTimeout);
                 }
                 // Save after a short delay to batch quick changes
                 this._saveStateTimeout = setTimeout(() => {
                     this.saveTabsState();
                 }, 1000); // Save 1 second after the last change
             }

            async saveTabsState(immediate = false) {
                if (this._saveStateTimeout && !immediate) {
                    // If a save is scheduled and this isn't an immediate request, let the schedule run
                     return;
                }
                 clearTimeout(this._saveStateTimeout); // Clear any pending timeout
                 this._saveStateTimeout = null;

                const tabsState = this.tabs.map(tab => tab.getState());
                try {
                    await this.storage.setSetting('tabsState', tabsState);
                    await this.storage.setSetting('activeTabId', this.activeTabId);
                    console.log("[TabManager] Saved tabs state to IndexedDB.");
                } catch (error) {
                    console.error("[TabManager] Failed to save tabs state:", error);
                }
            }
        }


        // --- History Manager ---
        class HistoryManager {
            constructor(app) {
                this.app = app;
                this.storage = app.storage;
                this._addHistoryDebounce = null; // To prevent rapid adds of same URL
                 this._lastAdded = { url: null, timestamp: 0 };
            }

            async addHistoryItem(url, title) {
                const trimmedUrl = url ? url.trim() : '';
                if (!trimmedUrl || trimmedUrl === 'about:blank' || trimmedUrl.startsWith(Config.INTERNAL_PROTOCOL)) {
                    return; // Don't log blank or internal pages
                }

                const now = Date.now();
                const cleanedTitle = title ? String(title).trim() : trimmedUrl;

                // Prevent adding the exact same URL too rapidly (e.g., accidental double clicks)
                 if (trimmedUrl === this._lastAdded.url && (now - this._lastAdded.timestamp < 3000)) { // 3 second threshold
                     // console.log(`[History] Debounced add for ${trimmedUrl}`);
                     return;
                 }

                 this._lastAdded = { url: trimmedUrl, timestamp: now };

                const item = {
                    url: trimmedUrl,
                    title: cleanedTitle,
                    timestamp: now
                };

                try {
                    // Add the item
                    const addedId = await this.storage.addItem(Config.STORE_HISTORY, item);
                    console.log(`[History] Added: ${item.url} (ID: ${addedId})`);
                    EventBus.publish('history-updated');

                    // Schedule cleanup (don't await, let it run in background)
                    this.cleanupOldHistory();

                } catch (error) {
                    console.error(`Error adding history item (${item.url}):`, error);
                }
            }

            async getHistoryItems(limit = 100) {
                try {
                    // Get items sorted by timestamp descending (most recent first)
                    return await this.storage.getAllItems(Config.STORE_HISTORY, 'timestamp', 'timestamp', 'prev', limit);
                } catch (error) {
                    console.error("Error getting history items:", error);
                    return [];
                }
            }

             async searchHistory(query, limit = 50) {
                 if (!query || query.trim().length === 0) {
                     return this.getHistoryItems(limit); // Return recent history if query is empty
                 }
                 const lowerQuery = query.toLowerCase();
                 try {
                     // Fetch a larger set to filter from (adjust limit as needed for performance)
                     const allItems = await this.getHistoryItems(Config.MAX_HISTORY_ITEMS * 2); // Fetch more than max keep limit for searching

                     const filteredItems = allItems.filter(item =>
                         (item.url && item.url.toLowerCase().includes(lowerQuery)) ||
                         (item.title && item.title.toLowerCase().includes(lowerQuery))
                     );

                     // Sort results (e.g., more recent first) - already sorted by getHistoryItems
                     return filteredItems.slice(0, limit); // Apply limit

                 } catch (error) {
                     console.error(`Error searching history for "${query}":`, error);
                     return [];
                 }
             }

            async clearHistory() {
                try {
                    await this.storage.clearStore(Config.STORE_HISTORY);
                    console.log("[History] Cleared all history items.");
                    this._lastAdded = { url: null, timestamp: 0 }; // Reset debounce check
                    EventBus.publish('history-updated');
                    this.app.ui.showToast("Browsing history cleared.");
                } catch (error) {
                    console.error("Error clearing history:", error);
                    this.app.ui.showToast("Failed to clear history.", "error");
                }
            }

            async cleanupOldHistory() {
                // Keep only the most recent MAX_HISTORY_ITEMS
                try {
                    // Get all items sorted by timestamp ascending (oldest first)
                     const allItems = await this.storage.getAllItems(Config.STORE_HISTORY, 'timestamp', 'timestamp', 'next');

                    if (allItems.length > Config.MAX_HISTORY_ITEMS) {
                        const itemsToDeleteCount = allItems.length - Config.MAX_HISTORY_ITEMS;
                        console.log(`[History] Found ${allItems.length} items, need to prune ${itemsToDeleteCount}.`);

                        // Iterate and delete the oldest items
                        for (let i = 0; i < itemsToDeleteCount; i++) {
                            if (allItems[i] && allItems[i].id) {
                                await this.storage.deleteItem(Config.STORE_HISTORY, allItems[i].id);
                            }
                        }
                        console.log(`[History] Pruned ${itemsToDeleteCount} old history items.`);
                         EventBus.publish('history-updated'); // Notify UI if cleanup happened
                    }
                } catch (error) {
                    console.error("Error cleaning up old history:", error);
                }
            }
        }


        // --- Bookmark Manager ---
        class BookmarkManager {
            constructor(app) {
                this.app = app;
                this.storage = app.storage;
                this.bookmarksCache = null; // Cache bookmarks for faster access
                this._loadPromise = null; // Prevent race conditions on load
            }

             // Load or reload bookmarks from storage into cache
             async loadBookmarks(forceReload = false) {
                 if (!forceReload && this.bookmarksCache !== null) {
                     return this.bookmarksCache; // Return cached version
                 }
                  if (this._loadPromise && !forceReload) {
                      return this._loadPromise; // Return existing load promise
                  }

                 console.log("[Bookmarks] Loading bookmarks from IndexedDB...");
                  this._loadPromise = new Promise(async (resolve, reject) => {
                       try {
                           // Get all items, sort by timestamp descending (most recent first)
                           const items = await this.storage.getAllItems(Config.STORE_BOOKMARKS, 'timestamp', 'timestamp', 'prev');
                           // Optional: Sort alphabetically by title after loading if preferred
                           // items.sort((a, b) => (a.title || a.url || '').localeCompare(b.title || b.url || ''));
                           this.bookmarksCache = items;
                           console.log(`[Bookmarks] Loaded ${items.length} bookmarks into cache.`);
                           EventBus.publish('bookmarks-updated');
                           resolve(this.bookmarksCache);
                       } catch (error) {
                           console.error("Error loading bookmarks:", error);
                           this.bookmarksCache = []; // Set empty cache on error
                           reject(error);
                       } finally {
                           this._loadPromise = null; // Clear the promise once done
                       }
                  });
                 return this._loadPromise;
             }

            async getBookmarks() {
                 // Ensure bookmarks are loaded before returning
                 return await this.loadBookmarks();
            }

             async addBookmark(url, title) {
                 const trimmedUrl = url ? url.trim() : '';
                 if (!trimmedUrl || trimmedUrl === 'about:blank' || trimmedUrl.startsWith(Config.INTERNAL_PROTOCOL)) {
                     this.app.ui.showToast("Cannot bookmark this internal or blank page.", "warn");
                     return false;
                 }
                  // Use isValidURL to ensure it's a bookmarkable format
                  const [isValid] = Utils.isValidURL(trimmedUrl);
                  if (!isValid && !trimmedUrl.startsWith('data:')) { // Allow data URLs
                      this.app.ui.showToast("Invalid URL format for bookmark.", "warn");
                      return false;
                  }


                 const timestamp = Date.now();
                 const cleanedTitle = title ? String(title).trim() : trimmedUrl;
                 const item = { url: trimmedUrl, title: cleanedTitle, timestamp };

                 try {
                     // Check if already exists using the 'url' index
                     const existing = await this.getBookmarkByURL(trimmedUrl);
                     if (existing) {
                         this.app.ui.showToast("Page is already bookmarked.", "info");
                         return false; // Indicate no change
                     }

                      // Limit number of bookmarks?
                      if (this.bookmarksCache && this.bookmarksCache.length >= Config.MAX_BOOKMARK_ITEMS) {
                          this.app.ui.showToast(`Maximum bookmarks (${Config.MAX_BOOKMARK_ITEMS}) reached.`, "warn");
                          return false;
                      }

                     // Add the new bookmark
                     const addedId = await this.storage.addItem(Config.STORE_BOOKMARKS, item);
                     console.log(`[Bookmarks] Added: ${item.url} (ID: ${addedId})`);

                     // Invalidate cache and reload, then update UI
                     await this.loadBookmarks(true); // Force reload
                     this.app.ui.showToast("Bookmark added.");
                     this.app.ui.updateBookmarkStatus(trimmedUrl); // Update icon immediately

                     return true; // Indicate success

                 } catch (error) {
                     // IndexedDB errors (like unique constraint violation) might occur here
                     if (error.name === 'ConstraintError') {
                          this.app.ui.showToast("Page is already bookmarked (database constraint).", "info");
                     } else {
                          console.error(`Error adding bookmark (${item.url}):`, error);
                          this.app.ui.showToast("Failed to add bookmark.", "error");
                     }
                     // Ensure cache is potentially reloaded if error occurred mid-process
                      await this.loadBookmarks(true);
                      this.app.ui.updateBookmarkStatus(trimmedUrl); // Update icon based on final state
                     return false;
                 }
             }

            async removeBookmark(id) {
                if (!id) return false;

                // Find the URL before removing for UI update
                const bookmarkToRemove = this.bookmarksCache?.find(b => b.id === id);
                const url = bookmarkToRemove?.url;

                try {
                    await this.storage.deleteItem(Config.STORE_BOOKMARKS, id);
                    console.log(`[Bookmarks] Removed bookmark ID: ${id} (URL: ${url || 'unknown'})`);

                    // Invalidate cache and reload
                    await this.loadBookmarks(true); // Force reload

                    this.app.ui.showToast("Bookmark removed.");
                    // Update bookmark icon if the removed bookmark was for the current page
                     const activeTab = this.app.tabManager.getActiveTab();
                    if (url && activeTab && activeTab.url === url) {
                        this.app.ui.updateBookmarkStatus(url);
                    }
                    return true;

                } catch (error) {
                    console.error(`Error removing bookmark ID ${id}:`, error);
                    this.app.ui.showToast("Failed to remove bookmark.", "error");
                    return false;
                }
            }

             async removeBookmarkByUrl(url) {
                 const bookmark = await this.getBookmarkByURL(url);
                 if (bookmark && bookmark.id) {
                     return await this.removeBookmark(bookmark.id);
                 }
                 return false; // Not found or no ID
             }

            async getBookmarkByURL(url) {
                 const trimmedUrl = url ? url.trim() : '';
                 if (!trimmedUrl) return null;

                 // Try cache first if available
                 if (this.bookmarksCache) {
                     const cached = this.bookmarksCache.find(b => b.url === trimmedUrl);
                     if (cached) return cached;
                 }

                 // If not in cache or cache empty, query DB using index
                 try {
                     const db = await this.storage.openDB();
                     return new Promise((resolve, reject) => {
                         const transaction = db.transaction(Config.STORE_BOOKMARKS, 'readonly');
                         const store = transaction.objectStore(Config.STORE_BOOKMARKS);
                         const index = store.index('url');
                         const request = index.get(trimmedUrl);

                         request.onsuccess = (event) => resolve(event.target.result || null); // Return null if not found
                         request.onerror = (event) => {
                              console.error(`DB error getting bookmark by URL ${trimmedUrl}:`, event.target.error);
                             reject(event.target.error);
                         };
                          transaction.onerror = (event) => reject(event.target.error);
                     });
                 } catch (error) {
                     console.error(`Error getting bookmark by URL ${trimmedUrl}:`, error);
                     return null;
                 }
             }

            async isBookmarked(url) {
                const bookmark = await this.getBookmarkByURL(url);
                return !!bookmark;
            }

            async clearBookmarks() {
                try {
                    await this.storage.clearStore(Config.STORE_BOOKMARKS);
                    console.log("[Bookmarks] Cleared all bookmarks.");

                    // Invalidate cache and reload
                    await this.loadBookmarks(true); // Force reload

                    this.app.ui.showToast("Bookmarks cleared.");

                    // Update bookmark icon for the current page
                    const activeTab = this.app.tabManager.getActiveTab();
                    if (activeTab) {
                        this.app.ui.updateBookmarkStatus(activeTab.url);
                    }
                } catch (error) {
                    console.error("Error clearing bookmarks:", error);
                    this.app.ui.showToast("Failed to clear bookmarks.", "error");
                }
            }
        }


        // --- Content Renderer ---
        // Responsible for taking a URL or prompt, getting content (via AI sim or internal),
        // processing it (sanitize, inject scripts), and displaying it in the tab's iframe via blob URL.
        class ContentRenderer {
            constructor(app) {
                this.app = app;
            }

             /**
              * Renders content for a given tab based on a URL or prompt.
              * Handles internal pages, AI generation for URLs/prompts, and error display.
              * @param {Tab} tab - The target tab object.
              * @param {string} urlOrPrompt - The URL or text prompt to render.
              */
             async render(tab, urlOrPrompt) {
                const cleanInput = String(urlOrPrompt).trim();
                console.log(`[Renderer] Rendering for Tab ${tab.id}: "${Utils.truncate(cleanInput, 100)}"`);

                tab.setIsLoading(true, 'Processing Request...', cleanInput);
                 tab.lastError = null; // Clear previous error state

                const [isValidUrl, normalizedUrl] = Utils.isValidURL(cleanInput);
                 const isInternal = !isValidUrl && cleanInput.startsWith(Config.INTERNAL_PROTOCOL);
                 const isSearch = !isValidUrl && !isInternal; // Assume search if not URL/Internal

                 const startTime = Date.now();
                 let networkLogEntry = {
                     url: cleanInput, // Log the original input
                     status: 'pending',
                     type: isInternal ? 'internal' : (isValidUrl ? 'navigation' : 'generation'),
                     startTime
                 };
                 EventBus.publish('network-request', networkLogEntry);

                 // Use a timeout to prevent hangs
                 const timeoutPromise = new Promise((_, reject) =>
                     setTimeout(() => reject(new Error('Content rendering timed out')), Config.LOADING_TIMEOUT)
                 );

                try {
                    let generatedHtml = '';
                     let pageTitle = '';
                     let finalUrl = cleanInput; // URL to associate with the content

                    // Wrap the core rendering logic to race against the timeout
                    const contentPromise = (async () => {
                        if (isInternal) {
                             console.log(`[Renderer] Rendering Internal Page: ${cleanInput}`);
                             networkLogEntry.type = 'internal';
                             const pageContent = await this._renderInternalPage(cleanInput);
                             generatedHtml = pageContent.html;
                             pageTitle = pageContent.title;
                             finalUrl = cleanInput;
                         } else if (isValidUrl) {
                             console.log(`[Renderer] Rendering URL (via AI Sim): ${normalizedUrl}`);
                             networkLogEntry.type = 'navigation';
                             networkLogEntry.url = normalizedUrl; // Log normalized URL
                             finalUrl = normalizedUrl; // Use normalized URL
                             tab.setUrl(finalUrl); // Update tab's URL state early

                             const prompt = this._createWebsitePrompt(finalUrl);
                             generatedHtml = await this.app.aiService.generateContent(prompt);
                             pageTitle = this._extractTitle(generatedHtml) || finalUrl.split('/')[2] || finalUrl; // Extract title or use domain/full URL
                         } else { // Must be a prompt/search query (isSearch is true)
                             console.log(`[Renderer] Rendering Prompt/Search (via AI Sim): ${cleanInput}`);
                             networkLogEntry.type = 'generation';
                             finalUrl = cleanInput; // Keep original prompt as the 'URL' for display
                             tab.setUrl(finalUrl); // Update tab's URL state

                             // Generate a snippet for raw prompts/searches
                             const prompt = this._createSnippetPrompt(cleanInput);
                             const generatedSnippet = await this.app.aiService.generateContent(prompt);
                             pageTitle = `Nexus Result: ${Utils.truncate(cleanInput, 30)}`;
                             // Wrap snippet in basic HTML structure for rendering
                             generatedHtml = this._wrapInBasicHtml(generatedSnippet, pageTitle);
                         }

                         // --- Content Processing and Display ---
                         // Ensure we have HTML, even if empty
                         generatedHtml = generatedHtml || this._createErrorPage(finalUrl, "AI service returned empty content.");

                         // Update the iframe content
                         this._updateIframe(tab, generatedHtml, finalUrl, pageTitle);

                         // Add to history only AFTER successful rendering and iframe update
                         tab.addToHistory(finalUrl, pageTitle || tab.title);

                         networkLogEntry.status = 'success';
                         return true; // Indicate success
                    })();

                     // Race the content generation against the timeout
                     await Promise.race([contentPromise, timeoutPromise]);

                } catch (error) {
                     console.error(`[Renderer] Error rendering Tab ${tab.id} (${cleanInput}):`, error);
                     tab.handleLoadError(error); // Use tab's error handling
                     networkLogEntry.status = 'error';
                     networkLogEntry.error = error.message;
                 } finally {
                     tab.setIsLoading(false); // Ensure loading state is cleared
                     networkLogEntry.endTime = Date.now();
                     EventBus.publish('network-request', networkLogEntry); // Update network log entry status
                 }
            }

             /**
              * Updates the tab's iframe with the given HTML content.
              * Handles sanitization, script injection, blob URL creation, and metadata updates.
              * @param {Tab} tab
              * @param {string} htmlContent
              * @param {string} sourceUrl - The URL/prompt this content represents.
              * @param {string} pageTitle
              */
             _updateIframe(tab, htmlContent, sourceUrl, pageTitle) {
                 if (!tab || !tab.iframe) {
                      console.error("[Renderer] Cannot update iframe: Tab or iframe element is missing.");
                      return;
                  }

                 // 1. Sanitize HTML (Crucial security step - limited effectiveness here)
                 const sanitizedHtml = Sanitizer.sanitize(htmlContent);
                 // console.log("[Renderer] Sanitized HTML (first 500 chars):", sanitizedHtml.substring(0, 500));

                 // 2. Inject DevTools Communication Script
                 const finalHtml = this._injectDevToolsScript(sanitizedHtml);

                 // 3. Clean up previous blob URL to release memory
                 tab.revokeBlobUrl();

                 // 4. Create Blob and Object URL
                 try {
                     const blob = new Blob([finalHtml], { type: 'text/html' });
                     tab.iframeBlobUrl = URL.createObjectURL(blob);
                     // console.log(`[Renderer] Created Blob URL for Tab ${tab.id}: ${tab.iframeBlobUrl.substring(0,50)}...`);

                     // Set the iframe source. This triggers the load.
                     tab.iframe.src = tab.iframeBlobUrl;

                 } catch (blobError) {
                     console.error("[Renderer] Error creating blob URL:", blobError);
                     // Display an error page within the iframe if blob creation fails
                     const errorHtml = this._createErrorPage(sourceUrl, `Failed to create content blob: ${blobError.message}`);
                     tab.iframe.srcdoc = errorHtml; // Use srcdoc as fallback for simple error message
                     tab.lastError = new Error("Failed to create content blob.");
                     pageTitle = "Blob Error";
                 }

                 // 5. Update Tab Metadata (Title, Favicon - needs enhancement)
                 tab.setTitle(pageTitle || "Untitled");
                 tab.setFavicon(); // Reset or extract favicon (TODO: Extract from generated HTML)

                  // 6. Update UI elements related to the tab's state
                  if (tab.manager.activeTabId === tab.id) {
                       tab.ui.updateBookmarkStatus(tab.url); // Use the tab's current URL state
                       tab.ui.updateSecurityIcon(tab.url);
                  }
             }

             /**
              * Injects the necessary JavaScript into the generated HTML string
              * to enable communication between the iframe and the parent window (DevTools).
              * @param {string} html - The HTML string to inject the script into.
              * @returns {string} HTML string with the script injected.
              */
             _injectDevToolsScript(html) {
                // Minimized script for injection
                const scriptContent = `
(function() {
    const targetOrigin = '*'; // WARNING: Use specific origin in production if not using blobs!
    const _nexusLog = (...args) => console.log('[NexusFrame]', ...args);
    _nexusLog('DevTools connector initializing...');

    // --- Console Proxy ---
    const originalConsole = {};
    ['log', 'warn', 'error', 'info', 'debug', 'table', 'clear'].forEach(level => {
        if (typeof console[level] !== 'function') return;
        originalConsole[level] = console[level].bind(console);
        console[level] = (...args) => {
            try { originalConsole[level](...args); } catch(e){/* Ignore errors in original console */}
            try {
                const serializedArgs = args.map(arg => {
                    try {
                        // Basic serialization, avoid circular refs, handle common types
                        if (arg instanceof Error) return { __error__: true, name: arg.name, message: arg.message, stack: arg.stack?.substring(0, 1000) };
                        if (arg instanceof Node) return \`<\${arg.nodeName.toLowerCase()}>\`;
                        if (arg instanceof Window) return '[Window]';
                        // Simple cycle detection placeholder (not robust)
                        return JSON.parse(JSON.stringify(arg, (key, value) => {
                             // Basic primitive handling is fine
                             if (typeof value !== 'object' || value === null) return value;
                             // Placeholder for complex objects - might need better handling
                             if (key.startsWith('_')) return '[Private]'; // Example: ignore private-like keys
                             return value;
                        }, 0)); // No pretty print here
                    } catch(e) { return \`[Serialization Error: \${String(e).substring(0,100)}]\`; }
                });
                window.parent.postMessage({ type: 'devtools-console', level: level, args: serializedArgs }, targetOrigin);
            } catch (e) { originalConsole.error('Nexus DevTools: Error posting console message:', e); }
        };
    });

    // --- Global Error Handler ---
    const handleError = (type, message, source, lineno, colno, error) => {
        _nexusLog('Caught error:', type, message, source, lineno);
        try {
            const errorData = {
                message: message || (error ? error.message : 'Unknown Error'),
                source: source,
                lineno: lineno,
                colno: colno,
                stack: error?.stack?.substring(0, 1000) // Limit stack trace length
            };
            window.parent.postMessage({ type: 'devtools-error', error: errorData }, targetOrigin);
        } catch(e) { originalConsole.error('Nexus DevTools: Error posting error event:', e); }
    };
    window.addEventListener('error', ev => handleError('error', ev.message, ev.filename, ev.lineno, ev.colno, ev.error));
    window.addEventListener('unhandledrejection', ev => handleError('unhandledrejection', 'Unhandled Promise Rejection', '', 0, 0, ev.reason));

    // --- DevTools Command Execution Listener ---
    window.addEventListener('message', event => {
        // Add origin check in production if not using blob URLs: if (event.origin !== 'expected_origin') return;
        if (event.data && event.source === window.parent) { // Ensure message is from parent
            _nexusLog('Received message from parent:', event.data.type);
            const { type, command, reqId } = event.data;
            if (type === 'devtools-execute') {
                let result, errorMsg;
                try {
                     // Use Function constructor for slightly safer evaluation than direct eval
                     result = (new Function(\`"use strict"; return (\${command})\`))();
                     // Basic serialization for result
                     try { result = JSON.parse(JSON.stringify(result === undefined ? null : result)); }
                     catch(e) { result = String(result); } // Fallback to string
                } catch (error) {
                    errorMsg = error.message;
                    console.error('Execution failed:', error); // Log error within iframe console too
                }
                window.parent.postMessage({ type: 'devtools-execute-result', result: result, error: errorMsg, reqId: reqId }, targetOrigin);

            } else if (type === 'devtools-get-html') {
                 let htmlContent, errorMsg;
                 try {
                     // Access outerHTML of the document element
                     htmlContent = document.documentElement?.outerHTML || document.body?.outerHTML || '';
                 } catch (error) {
                     errorMsg = error.message;
                     console.error('Failed to get HTML:', error);
                 }
                window.parent.postMessage({ type: 'devtools-html-content', html: htmlContent, error: errorMsg, reqId: reqId }, targetOrigin);
            }
             // Add listener for navigation requests from internal pages
             else if (type === 'nexus-navigate' && event.data.url) {
                _nexusLog('Forwarding navigation request to parent:', event.data.url);
                 window.parent.postMessage({ type: 'nexus-navigate-request', url: event.data.url }, targetOrigin);
             }
        }
    });

    _nexusLog('DevTools connector initialized.');
})();
`;
                 // Inject the script
                 const scriptTag = `<script>${scriptContent}</script>`;
                 // Try to inject reliably: just before </head> or </body>, or append to body/html
                 if (html.includes('</head>')) {
                     return html.replace('</head>', `${scriptTag}</head>`);
                 } else if (html.includes('</body>')) {
                     return html.replace('</body>', `${scriptTag}</body>`);
                 } else if (html.includes('</html>')) {
                      return html.replace('</html>', `${scriptTag}</html>`);
                 } else {
                      // Fallback: Append to the end (less reliable for execution timing)
                      return html + scriptTag;
                 }
             }


            /** Prompts for the AI Simulation */
            _createWebsitePrompt(url) {
                const domainMatch = url.match(/^(?:https?:\/\/)?(?:[^@\n]+@)?(?:www\.)?([^:\/\n?#]+)/im);
                const topic = domainMatch ? domainMatch[1] : url; // Use domain as topic
                return `Generate the COMPLETE HTML source code for a sleek, moderately complex, futuristic website themed around "${topic}" (derived from URL: ${url}). Imagine a design from the year 2050.

**STYLE REQUIREMENTS:**
1.  **Complete HTML:** Must include <!DOCTYPE html>, <head> with <title>${Utils.escapeHtml(topic)} - Nexus Portal</title> and relevant <meta> tags, and <body>.
2.  **CSS:** Use INLINE STYLE attributes (style="...") extensively. A single <style> block in the <head> is ALLOWED ONLY for:
    *   Basic body/root variables (e.g., :root { --sim-bg: #...; }).
    *   Very simple global element styles (e.g., body { font-family:...; }).
    *   ONE or TWO simple @keyframes animations (e.g., subtle pulse, glow, or gradient shift). NO complex layout rules in the <style> block.
3.  **Futuristic Aesthetic (2050):**
    *   LAYOUT: Use divs. Simple inline flexbox (style="display:flex; justify-content:center;") is OK. AVOID complex grids or floats. Structure should resemble a simple landing page (header/nav, main content sections, footer).
    *   FONTS: Use common web-safe sans-serif fonts (e.g., 'Inter', 'Segoe UI', sans-serif) via inline style or the basic body style. NO <font> tags.
    *   COLORS: Use a futuristic palette. Dark themes (dark blues, grays, purples with neon accents like #8ab4f8, #f28b82, #a1ffc8) or light themes (clean whites, light grays with bright blue/teal accents) are good. Use hex or rgba. Inline linear-gradient backgrounds are acceptable.
    *   GRAPHICS: Include 1-2 placeholder images using simple SVG data URLs (like <img src="data:image/svg+xml,%3Csvg...%3E%3C/svg%3E") or placeholder text within styled divs. Style them with border-radius, maybe subtle opacity or filter.
    *   CONTENT: Relate placeholder text loosely to "${topic}". Use futuristic-sounding terms ("Data Stream", "Quantum Analysis", "Neural Link Status", "Holo-Display"). Include placeholder navigation links (<a> tags with # hrefs).
    *   ANIMATION: If using @keyframes, keep it subtle (e.g., background glow, slow pulse). Inline transitions (style="transition: transform 0.3s;") on hover are OK. NO <marquee>, <blink>.
    *   INTERACTIVITY: Basic styled links (<a>). Maybe a styled disabled button (style="opacity:0.5; cursor:not-allowed;").
4.  **NO JavaScript:** Absolutely NO <script> tags or inline JavaScript event handlers (onclick=, etc.) in the generated HTML output itself (the DevTools script will be injected later).
5.  **Simplicity & Length:** Keep HTML structure reasonable (e.g., under ~400 lines total). Focus on achieving the look via inline styles primarily.
6.  **Output:** Respond ONLY with the raw HTML code, starting directly with <!DOCTYPE html>. Do not include any explanations, markdown formatting, or text before or after the HTML code block.`;
            }

            _createSnippetPrompt(promptText) {
                return `Generate a VERY simple, single, self-contained HTML snippet (content for a <body> tag, likely a single <div> or similar) based on the prompt "${Utils.escapeHtml(promptText)}".

**STYLE REQUIREMENTS:**
1.  **HTML:** Output only the HTML for the snippet itself (e.g., one main container div). Do NOT include <!DOCTYPE>, <html>, <head>, or <body> tags.
2.  **CSS:** Use ONLY inline style attributes (style="..."). NO <style> blocks allowed AT ALL.
3.  **Futuristic Aesthetic (Minimal):** Aim for a clean, minimal 2050s look within the snippet (e.g., subtle border, background color hint, appropriate text colors based on a typical dark or light theme, sans-serif font). Use hex or rgba colors.
4.  **Content:** Directly address the prompt "${Utils.escapeHtml(promptText)}" with placeholder text.
5.  **Graphics:** Optionally include ONE very simple inline SVG icon relevant to the prompt (e.g., using a data:image/svg+xml URL).
6.  **NO JavaScript:** No <script> or inline JS.
7.  **Length:** Keep the snippet SHORT (e.g., 5-15 lines of HTML maximum).
8.  **Output:** Respond ONLY with the raw HTML snippet code. No explanations, markdown, or other text.`;
            }

             /**
              * Wraps generated body content in a basic HTML structure with minimal styling.
              * @param {string} bodyContent - The HTML content for the body.
              * @param {string} title - The page title.
              * @returns {string} Full HTML document string.
              */
             _wrapInBasicHtml(bodyContent, title) {
                 const safeTitle = Utils.escapeHtml(title) || 'Nexus Browser';
                 const theme = document.documentElement.getAttribute('theme') || 'dark';
                 const isDark = theme === 'dark';
                 // Basic wrapper, attempts to match browser theme for consistency
                 return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>${safeTitle}</title>
    <style>
        :root { /* Simplified theme vars for wrapper */
            --sim-bg: ${isDark ? '#1a1b1e' : '#f8f9fa'};
            --sim-text: ${isDark ? '#e8eaed' : '#202124'};
            --sim-accent: ${isDark ? '#8ab4f8' : '#1a73e8'};
            --sim-border: ${isDark ? '#3c4043' : '#dadce0'};
            --sim-secondary-text: ${isDark ? '#9aa0a6' : '#5f6368'};
            --sim-link-hover: ${isDark ? '#a7c5f9' : '#1558b0'};
            --sim-code-bg: rgba(${isDark ? '255,255,255,0.1' : '0,0,0,0.05'});
            --sim-space-m: 16px;
            --sim-radius: 6px;
        }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--sim-bg);
            color: var(--sim-text);
            padding: var(--sim-space-m) calc(var(--sim-space-m) * 1.5);
            margin: 0;
            line-height: 1.6;
        }
        h1, h2, h3 { color: var(--sim-accent); margin-bottom: 0.7em; font-weight: 500; border-bottom: 1px solid var(--sim-border); padding-bottom: 0.3em;}
        h1 { font-size: 1.8em; } h2 { font-size: 1.5em; } h3 { font-size: 1.2em; }
        p { margin-bottom: 1em; color: var(--sim-secondary-text); max-width: 70ch; } /* Limit paragraph width */
        a { color: var(--sim-accent); text-decoration: none; }
        a:hover { text-decoration: underline; color: var(--sim-link-hover); }
        img { max-width: 100%; height: auto; border-radius: var(--sim-radius); border: 1px solid var(--sim-border); margin: 5px 0; }
        hr { border: none; border-top: 1px dashed var(--sim-border); margin: 1.5em 0; }
        pre, code { font-family: 'Roboto Mono', monospace; background-color: var(--sim-code-bg); padding: 0.1em 0.4em; border-radius: 4px; font-size: 0.9em; }
        pre { padding: var(--sim-space-m); overflow-x: auto; border: 1px solid var(--sim-border); }
        ul, ol { padding-left: 2em; margin-bottom: 1em; }
        li { margin-bottom: 0.5em; }
        table { width: 100%; border-collapse: collapse; margin-bottom: 1em; }
        th, td { border: 1px solid var(--sim-border); padding: 0.5em; text-align: left; }
        th { background-color: var(--sim-code-bg); }
        blockquote { border-left: 4px solid var(--sim-border); margin-left: 0; padding-left: 1em; font-style: italic; color: var(--sim-secondary-text); }
    </style>
</head>
<body>
    ${bodyContent}
</body>
</html>`;
            }

             /**
              * Generates HTML for a standardized error page.
              * @param {string} url - The URL or prompt that caused the error.
              * @param {string} errorMessage - The error message.
              * @returns {string} Full HTML document string for the error page.
              */
             _createErrorPage(url, errorMessage) {
                 const safeUrl = Utils.escapeHtml(url);
                 const safeError = Utils.escapeHtml(errorMessage);
                 const theme = document.documentElement.getAttribute('theme') || 'dark';
                 const isDark = theme === 'dark';
                 return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Nexus Render Error</title>
    <style>
        :root {
            --err-bg: ${isDark ? '#1a1b1e' : '#f8f9fa'};
            --err-text: ${isDark ? '#e8eaed' : '#202124'};
            --err-secondary: ${isDark ? '#9aa0a6' : '#5f6368'};
            --err-accent: ${isDark ? '#f28b82' : '#d93025'}; /* Error color */
            --err-border: ${isDark ? '#5f6368' : '#dadce0'};
            --err-code-bg: rgba(${isDark ? '242, 139, 130, 0.1' : '217, 48, 37, 0.05'});
            --err-space-l: 20px;
        }
        body {
            font-family: 'Inter', sans-serif; background-color: var(--err-bg); color: var(--err-text);
            padding: calc(var(--err-space-l) * 2); display: flex; justify-content: center; align-items: center; min-height: 80vh; margin: 0;
        }
        .error-container {
            border: 1px solid var(--err-border); border-left: 5px solid var(--err-accent);
            border-radius: 8px; padding: calc(var(--err-space-l) * 1.5);
            background-color: rgba(${isDark ? '0,0,0,0.1' : '255,255,255,0.5'});
            max-width: 650px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        h2 {
            color: var(--err-accent); margin: 0 0 var(--err-space-l) 0; font-size: 22px; font-weight: 500;
            display: flex; align-items: center; justify-content: center; gap: 10px;
        }
        h2 span { font-size: 28px; line-height: 1; } /* Icon size */
        p { color: var(--err-secondary); margin-bottom: var(--err-space-l); line-height: 1.6; }
        code {
            display: inline-block; background-color: var(--err-code-bg); padding: 5px 10px; border-radius: 4px;
            font-family: 'Roboto Mono', monospace; word-break: break-all; border: 1px solid var(--err-accent);
             color: var(--err-accent); font-size: 0.9em;
        }
        .details {
            font-size: 13px; color: var(--err-secondary); margin-top: var(--err-space-l);
            border-top: 1px dashed var(--err-border); padding-top: var(--err-space-l);
             text-align: left;
        }
        .details strong { color: var(--err-text); }
    </style>
</head>
<body>
<div class="error-container">
    <h2><span aria-hidden="true">⚠️</span> System Error</h2>
    <p>Nexus encountered a problem processing the request for:</p>
    <p><code>${safeUrl}</code></p>
    <div class="details"><strong>Details:</strong> ${safeError}</div>
</div>
</body>
</html>`;
             }


            _extractTitle(html) {
                 // More robust title extraction, handling different casing and attributes
                 const titleMatch = html.match(/<title(?:\s+[^>]*)?>(.*?)<\/title\s*>/i);
                 if (titleMatch && titleMatch[1]) {
                     // Decode HTML entities and trim
                     const tempDiv = document.createElement('div');
                     tempDiv.innerHTML = titleMatch[1];
                     return tempDiv.textContent?.trim() || '';
                 }
                 return null;
             }

             /**
              * Generates HTML content for internal "future:" protocol pages.
              * @param {string} url - The full internal URL (e.g., "future:newtab").
              * @returns {Promise<{html: string, title: string}>}
              */
             async _renderInternalPage(url) {
                  const safeUrl = Utils.escapeHtml(url);
                  let title = 'Nexus';
                  let bodyContent = '';
                  let page = 'about'; // Default page

                  try {
                      const urlParts = new URL(url); // Use URL parser for internal paths too
                      page = urlParts.pathname || 'about';
                      const params = urlParts.searchParams;

                      // Basic styling for internal pages
                      const theme = document.documentElement.getAttribute('theme') || 'dark';
                      const isDark = theme === 'dark';
                      const commonStyle = `
:root { /* Simplified theme vars for internal page */
    --int-bg: ${isDark ? '#1a1b1e' : '#f8f9fa'};
    --int-text: ${isDark ? '#e8eaed' : '#202124'};
    --int-accent: ${isDark ? '#8ab4f8' : '#1a73e8'};
    --int-border: ${isDark ? '#3c4043' : '#dadce0'};
    --int-secondary-text: ${isDark ? '#9aa0a6' : '#5f6368'};
    --int-link-hover: ${isDark ? '#a7c5f9' : '#1558b0'};
    --int-code-bg: rgba(${isDark ? '255,255,255,0.1' : '0,0,0,0.05'});
    --int-space-m: 16px; --int-space-l: 24px;
    --int-radius: 6px;
}
body { font-family: 'Inter', sans-serif; padding: var(--int-space-l); background-color: var(--int-bg); color: var(--int-text); line-height: 1.6; margin: 0; }
.page-container { max-width: 800px; margin: 20px auto; }
h2 { color: var(--int-accent); border-bottom: 1px solid var(--int-border); padding-bottom: 0.4em; margin: 0 0 1em 0; font-weight: 500; font-size: 1.8em;}
h3 { color: var(--int-text); margin: 1.5em 0 0.5em 0; font-weight: 500; font-size: 1.3em; }
ul { list-style: none; padding: 0; }
li { margin-bottom: 0.6em; background: rgba(${isDark ? '255,255,255,0.03' : '0,0,0,0.02'}); padding: 0.8em 1em; border-radius: var(--int-radius); border: 1px solid var(--int-border); }
a { color: var(--int-accent); text-decoration: none; }
a:hover { text-decoration: underline; color: var(--int-link-hover); }
button { /* Basic button - uses nexus-button style from wrapper usually */ }
code { background-color: var(--int-code-bg); padding: 0.1em 0.4em; border-radius: 4px; font-size: 0.9em; border: 1px solid var(--int-border);}
.nexus-input { /* Basic input styling if needed directly */
    background-color: var(--int-bg); border: 1px solid var(--int-border); border-radius: var(--int-radius);
    padding: 8px 12px; color: var(--int-text); font-size: 14px; width: 100%; outline: none;
}
.nexus-input:focus { border-color: var(--int-accent); box-shadow: 0 0 0 2px rgba(${isDark ? '138,180,248,0.3' : '26,115,232,0.3'}); }
`;

                      switch (page) {
                          case 'newtab':
                              title = 'New Tab - Nexus';
                              bodyContent = `
<style>
    ${commonStyle}
    body { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 80vh; text-align: center; }
    .logo { font-size: 72px; margin-bottom: 20px; color: var(--int-accent); text-shadow: 0 0 20px rgba(${isDark ? '138, 180, 248, 0.4' : '26, 115, 232, 0.4'}); font-weight: 300; }
    .tagline { font-size: 1.1em; color: var(--int-secondary-text); margin-bottom: 30px; }
    .search-input { width: 70%; max-width: 550px; margin-top: 10px; padding: 12px 20px; font-size: 16px; border-radius: 30px; /* Pill shape */ }
    .quick-links { margin-top: 40px; display: flex; gap: 25px; justify-content: center; }
    .quick-links a { color: var(--int-secondary-text); font-size: 13px; display: flex; flex-direction: column; align-items: center; gap: 5px; transition: color 0.2s ease; }
    .quick-links a:hover { color: var(--int-accent); text-decoration: none; }
    .quick-links span { font-size: 24px; } /* Icon size */
</style>
<div class="page-container">
    <div class="logo">N</div>
    <p class="tagline">Nexus Browser 2050</p>
    <input type="text" class="nexus-input search-input" id="newtab-search" placeholder="Search the web or enter address..." autofocus aria-label="Search or enter address">
    <div class="quick-links">
        <a href="#" data-navigate="${Config.INTERNAL_PROTOCOL}history">
             <span class="material-symbols-rounded" style="font-size: 24px;">history</span> History
        </a>
        <a href="#" data-navigate="${Config.INTERNAL_PROTOCOL}bookmarks">
            <span class="material-symbols-rounded" style="font-size: 24px;">bookmarks</span> Bookmarks
        </a>
        <a href="#" data-navigate="${Config.INTERNAL_PROTOCOL}settings">
             <span class="material-symbols-rounded" style="font-size: 24px;">settings</span> Settings
        </a>
         <a href="#" data-navigate="${Config.INTERNAL_PROTOCOL}about">
             <span class="material-symbols-rounded" style="font-size: 24px;">info</span> About
        </a>
    </div>
</div>
<script>
    // Use postMessage to request navigation from the parent
    document.getElementById('newtab-search')?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && e.target.value) {
             console.log('Newtab search triggered:', e.target.value);
            window.parent.postMessage({ type: 'nexus-navigate-request', url: e.target.value }, '*'); // Use '*' for blob origins
        }
    });
    document.querySelectorAll('.quick-links a[data-navigate]').forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            const targetUrl = e.target.closest('a').getAttribute('data-navigate');
             console.log('Newtab link clicked:', targetUrl);
            if (targetUrl) window.parent.postMessage({ type: 'nexus-navigate-request', url: targetUrl }, '*');
        });
    });
</script>
`;
                              break;

                          case 'history':
                          case 'bookmarks':
                          case 'settings':
                              // These are now primarily handled by UI Manager dialogs,
                              // so the internal page is just a placeholder.
                              const panelName = page.charAt(0).toUpperCase() + page.slice(1);
                              title = `${panelName} - Nexus`;
                              bodyContent = `
<style>${commonStyle}</style>
<div class="page-container">
    <h2>${panelName}</h2>
    <p>Your ${page} are managed through the dedicated panel.</p>
    <p>Click the corresponding icon in the toolbar or use keyboard shortcuts:</p>
    <ul>
        ${page === 'history' ? '<li>History Panel: Ctrl+H (or Cmd+H)</li>' : ''}
        ${page === 'bookmarks' ? '<li>Bookmarks Panel: Ctrl+B (or Cmd+B)</li>' : ''}
        ${page === 'settings' ? '<li>Settings Panel: Click the ⚙️ icon</li>' : ''}
    </ul>
</div>`;
                              break;

                          case 'about':
                              title = 'About Nexus Browser';
                              bodyContent = `
<style>
    ${commonStyle}
    .version { font-size: 12px; color: var(--int-secondary-text); margin-top: 30px; text-align: center; opacity: 0.8; }
    .features li { background: none; border: none; padding: 0.2em 0; }
     .features li::before { content: '⚡'; margin-right: 10px; color: var(--int-accent); }
</style>
<div class="page-container">
    <h2>About Nexus Browser 2050</h2>
    <p>A conceptual futuristic browser interface focusing on minimalism, AI-driven content rendering (simulation), and robust client-side operation within a single HTML file.</p>
    <h3>Core Concepts Simulation:</h3>
    <ul class="features">
        <li>Serverless Architecture (Client-side JS & IndexedDB storage)</li>
        <li>AI Content Generation Simulation (Using predefined templates & styles)</li>
        <li>Modern UI/UX (Minimalist, Adaptive Theme)</li>
        <li>Integrated Developer Tools (Console, Elements, Network Sim, Application Storage)</li>
        <li>Blob URLs & Sandboxing for Rendered Content</li>
        <li>Persistence via IndexedDB (History, Bookmarks, Settings, Tabs)</li>
    </ul>
    <p>This browser simulation uses <code>${Config.INTERNAL_PROTOCOL}</code> for internal pages like this one.</p>
    <p class="version">Nexus Core Version: 1.0 (Simulation)</p>
</div>`;
                              break;

                          default:
                              title = 'Unknown Page';
                              bodyContent = `
<style>${commonStyle}</style>
<div class="page-container">
    <h2>Resource Not Found</h2>
    <p>The requested internal Nexus resource could not be located:</p>
    <p><code>${safeUrl}</code></p>
     <p>Please check the address or navigate using the toolbar buttons.</p>
</div>`;
                              break;
                      }

                       // Wrap the generated body content
                       const fullHtml = this._wrapInBasicHtml(bodyContent, title);
                       return { html: fullHtml, title: title };

                  } catch (error) {
                      console.error(`Error generating internal page ${url}:`, error);
                      return {
                          html: this._createErrorPage(url, `Error generating internal page: ${error.message}`),
                          title: "Internal Error"
                      };
                  }
              }
        }


        // --- DevTools Manager ---
        class DevTools {
            constructor(app) {
                this.app = app;
                this.uiManager = app.uiManager;
                this.storage = app.storage;
                this.activeTab = null; // Reference to the currently inspected tab
                this.isOpen = false;
                this.activePane = 'console'; // Default pane
                this.dom = {
                    panel: document.getElementById('devtools-panel'),
                    toolbar: document.querySelector('.devtools-toolbar'),
                    content: document.querySelector('.devtools-content'),
                    panes: document.querySelectorAll('.devtools-pane'),
                    tabs: document.querySelectorAll('.devtools-tab'),
                    closeButton: document.getElementById('devtools-close-button'),
                    // Console
                    consoleOutput: document.getElementById('console-output'),
                    consoleInput: document.getElementById('console-input'),
                    // Elements
                    elementsView: document.getElementById('elements-view'),
                    // Network
                    networkLog: document.getElementById('network-log'),
                    // Application
                     historyStorageTable: document.getElementById('history-storage-table').querySelector('tbody'),
                     bookmarksStorageTable: document.getElementById('bookmarks-storage-table').querySelector('tbody'),
                     clearHistoryStorageBtn: document.getElementById('clear-history-storage'),
                     clearBookmarksStorageBtn: document.getElementById('clear-bookmarks-storage'),
                };
                this.messageListeners = new Map(); // Store listeners for async messages

                this._attachListeners();
                 // Set initial height from config
                this.dom.panel.style.height = Config.DEVTOOLS_INITIAL_HEIGHT;

                // Subscribe to events AFTER DOM is ready
                 EventBus.subscribe('active-tab-changed', this.onActiveTabChanged.bind(this));
                 EventBus.subscribe('network-request', this.logNetworkRequest.bind(this));
                 EventBus.subscribe('history-updated', this.updateApplicationStorageView.bind(this));
                 EventBus.subscribe('bookmarks-updated', this.updateApplicationStorageView.bind(this));

                 // Global listener for messages FROM iframes
                 window.addEventListener('message', this.handleIframeMessage.bind(this));
            }

            _attachListeners() {
                 // Toggle DevTools with F12 or status bar icon
                 window.addEventListener('keydown', (e) => {
                     if (e.key === 'F12' && !e.altKey && !e.ctrlKey && !e.metaKey) {
                         e.preventDefault();
                         this.toggle();
                     }
                 });
                 this.uiManager.dom.devtoolsStatusIcon.addEventListener('click', () => this.toggle());
                 this.dom.closeButton.addEventListener('click', () => this.close());

                 // Switch DevTools tabs
                 this.dom.toolbar.addEventListener('click', (e) => {
                     const tabButton = e.target.closest('.devtools-tab');
                     if (tabButton && !tabButton.classList.contains('active')) {
                         this.switchPane(tabButton.dataset.pane);
                     }
                 });

                 // Console Input Execution
                 this.dom.consoleInput.addEventListener('keydown', (e) => {
                     if (e.key === 'Enter' && this.dom.consoleInput.value.trim()) {
                         e.preventDefault(); // Prevent newline in input
                         this.executeConsoleCommand(this.dom.consoleInput.value);
                         this.dom.consoleInput.value = ''; // Clear input after execution
                     }
                      // TODO: Add history (ArrowUp/ArrowDown) for console input
                 });

                 // Application Storage Buttons
                 this.dom.clearHistoryStorageBtn.addEventListener('click', async () => {
                     if (confirm('Are you sure you want to permanently clear all browsing history from storage?')) {
                          await this.app.historyManager.clearHistory();
                          this.logToConsole('info', 'History storage cleared.', 'DevTools');
                     }
                 });
                 this.dom.clearBookmarksStorageBtn.addEventListener('click', async () => {
                     if (confirm('Are you sure you want to permanently clear all bookmarks from storage?')) {
                         await this.app.bookmarkManager.clearBookmarks();
                         this.logToConsole('info', 'Bookmarks storage cleared.', 'DevTools');
                     }
                 });
             }

            onActiveTabChanged(tabInstance) {
                if (!tabInstance) return;
                // console.log(`[DevTools] Active tab changed to: ${tabInstance.id}`);
                this.activeTab = tabInstance;
                // Refresh DevTools content only if it's currently open
                if (this.isOpen) {
                    this.refreshContentForActiveTab();
                }
            }

            // Refreshes content based on the currently set this.activeTab
             refreshContentForActiveTab() {
                 if (!this.activeTab) {
                     console.warn("[DevTools] Refresh called with no active tab.");
                     // Optionally clear panes or show a message
                     this.clearConsole();
                     this.clearNetworkLog();
                     this.dom.elementsView.textContent = '// No active page to inspect.';
                     this.updateApplicationStorageView(); // Update storage view regardless of tab
                     return;
                 }
                 console.log(`[DevTools] Refreshing content for active tab: ${this.activeTab.id}`);

                 // Clear volatile panes
                 this.clearConsole();
                 this.clearNetworkLog(); // Or maybe keep network log persistent? Decision needed. Let's clear for now.

                 // Log context info
                 this.logToConsole('info', `Inspecting: ${this.activeTab.url}`, 'DevTools');
                 this.logToConsole('info', `Tab ID: ${this.activeTab.id}`, 'DevTools');
                 if (this.activeTab.lastError) {
                     this.logToConsole('error', `Last Load Error: ${this.activeTab.lastError.message}`, 'DevTools');
                 }

                 // Refresh the currently active pane
                 this.updateActivePaneContent();
             }

             // Update content specifically for the currently visible pane
             updateActivePaneContent() {
                  if (!this.isOpen) return;
                  console.log(`[DevTools] Updating active pane: ${this.activePane}`);
                  switch (this.activePane) {
                       case 'console':
                           // Console updates via logs, maybe re-log context? Already done in refreshContentForActiveTab.
                           this.dom.consoleInput.focus();
                           break;
                       case 'elements':
                           this.updateElementsView();
                           break;
                       case 'network':
                           // Network log is appended to, clearing happens on tab change.
                           break;
                       case 'application':
                           this.updateApplicationStorageView();
                           break;
                       default:
                           console.warn(`[DevTools] Attempted to update unknown pane: ${this.activePane}`);
                  }
             }

             toggle() {
                 this.isOpen ? this.close() : this.open();
             }

             open() {
                 if (this.isOpen) return;
                 console.log("[DevTools] Opening panel.");
                 this.dom.panel.style.display = 'flex'; // Show the panel
                 this.isOpen = true;
                 // Ensure we have the latest active tab reference
                 this.activeTab = this.app.tabManager.getActiveTab();
                 // Refresh content for the newly opened panel
                 this.refreshContentForActiveTab();
                 this.uiManager.dom.devtoolsStatusIcon.style.color = 'var(--accent-primary)';
                 this.uiManager.dom.devtoolsStatusIcon.setAttribute('aria-pressed', 'true');
                  // Persist open state? Maybe later.
             }

             close() {
                 if (!this.isOpen) return;
                 console.log("[DevTools] Closing panel.");
                 this.dom.panel.style.display = 'none'; // Hide the panel
                 this.isOpen = false;
                 this.uiManager.dom.devtoolsStatusIcon.style.color = ''; // Reset color
                  this.uiManager.dom.devtoolsStatusIcon.setAttribute('aria-pressed', 'false');
                 // Persist closed state?
             }

             switchPane(paneId) {
                 if (this.activePane === paneId) return;
                 console.log(`[DevTools] Switching pane to: ${paneId}`);

                 this.dom.tabs.forEach(tab => tab.classList.toggle('active', tab.dataset.pane === paneId));
                 this.dom.panes.forEach(pane => pane.classList.toggle('active', pane.dataset.pane === paneId));
                 this.activePane = paneId;

                 // Update content for the newly selected pane
                 this.updateActivePaneContent();
             }

            // --- Console ---
             logToConsole(level, message, source = 'Browser') {
                 // Only log errors if DevTools is closed, otherwise log everything
                 if (!this.isOpen && level !== 'error') return;

                 const timestamp = new Date().toLocaleTimeString([], {
                     hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3
                 });

                 const entry = Utils.createElement('div', ['console-entry', level]);
                 const timeEl = Utils.createElement('span', ['console-timestamp'], {}, timestamp);
                 const sourceEl = Utils.createElement('span', ['console-source'], {}, `[${source}]`);
                 const msgContainer = Utils.createElement('span', ['console-message']);

                  // Handle single message or array of messages/args
                  const messages = Array.isArray(message) ? message : [message];
                  messages.forEach((msg, index) => {
                      const span = Utils.createElement('span');
                      if (typeof msg === 'object' && msg !== null) {
                          // Basic object formatting
                           try {
                               span.textContent = JSON.stringify(msg, null, 2); // Pretty print object
                               span.style.whiteSpace = 'pre'; // Preserve formatting
                           } catch (e) { span.textContent = '[Unserializable Object]'; }
                      } else {
                           span.textContent = String(msg); // Convert non-objects to string
                      }
                      msgContainer.appendChild(span);
                      // Add space between arguments
                       if (index < messages.length - 1) {
                           msgContainer.appendChild(document.createTextNode(' '));
                       }
                  });


                 entry.append(timeEl, sourceEl, msgContainer);
                 this.dom.consoleOutput.appendChild(entry);

                 // Auto-scroll to bottom, but only if user isn't scrolled up
                 const isScrolledToBottom = this.dom.consoleOutput.scrollHeight - this.dom.consoleOutput.clientHeight <= this.dom.consoleOutput.scrollTop + 5; // Add tolerance
                 if (isScrolledToBottom) {
                     this.dom.consoleOutput.scrollTop = this.dom.consoleOutput.scrollHeight;
                 }
             }

             clearConsole() {
                 this.dom.consoleOutput.innerHTML = '';
                  this.logToConsole('info', 'Console was cleared.', 'DevTools');
             }

             executeConsoleCommand(command) {
                  if (!this.activeTab || !this.activeTab.iframe || !this.activeTab.iframe.contentWindow) {
                      this.logToConsole('error', 'No active iframe context available to execute command.', 'DevTools');
                      return;
                  }

                  // Log the input command with a specific style? Maybe just use source 'Input'
                  this.logToConsole('log', command, 'Input'); // Log as Input source

                  const reqId = Utils.generateId('exec_');

                  // Use a promise to wait for the result message back from the iframe
                  const resultPromise = new Promise((resolve, reject) => {
                       const listener = (event) => {
                           // Basic origin check (might be needed if not using blobs exclusively)
                           // if (event.origin !== expectedOrigin) return;
                           if (event.data && event.data.type === 'devtools-execute-result' && event.data.reqId === reqId) {
                               window.removeEventListener('message', listener); // Clean up listener
                               this.messageListeners.delete(reqId);
                                if (event.data.error) {
                                    reject(new Error(event.data.error)); // Reject promise with error message
                                } else {
                                     resolve(event.data.result); // Resolve with the result
                                }
                            }
                       };
                       window.addEventListener('message', listener);
                       this.messageListeners.set(reqId, listener); // Store for potential cleanup
                         // Timeout for the response
                         setTimeout(() => {
                              if (this.messageListeners.has(reqId)) {
                                   window.removeEventListener('message', listener);
                                   this.messageListeners.delete(reqId);
                                   reject(new Error(`Command execution timed out (reqId: ${reqId})`));
                              }
                         }, 5000); // 5 second timeout
                   });

                   // Send the command to the iframe
                   this.activeTab.iframe.contentWindow.postMessage({ type: 'devtools-execute', command, reqId }, '*'); // Use '*' for blob origins

                  // Handle the promise result/error
                   resultPromise
                       .then(result => {
                           // Log the result with a specific style/prefix
                           this.logToConsole('log', result, '<'); // Log as result/output source '<'
                       })
                       .catch(error => {
                            // Log the error message
                           this.logToConsole('error', `❌ ${error.message}`, 'IFrame');
                       });
             }

            // --- Message Handling ---
             handleIframeMessage(event) {
                 // IMPORTANT: Add origin check in a real application if not using blob URLs exclusively
                 // For blob URLs, source check is more reliable.
                 // if (event.origin !== 'expected_origin') return;

                 const data = event.data;
                 if (!data || typeof data !== 'object') return; // Ignore invalid messages

                 // Ensure the message comes from the currently active iframe's contentWindow
                  const activeIframeContentWindow = this.activeTab?.iframe?.contentWindow;
                  if (!activeIframeContentWindow || event.source !== activeIframeContentWindow) {
                       // console.warn("DevTools received message from inactive/unknown source", event.source);
                       return; // Ignore messages not from the active iframe
                   }

                 // Process known message types
                 switch (data.type) {
                      case 'devtools-console':
                           this.logToConsole(data.level || 'log', data.args || ['(No message content)'], 'IFrame');
                           break;
                      case 'devtools-error':
                           const err = data.error || {};
                           this.logToConsole('error', `Uncaught ${err.message || '(No message)'}${err.source ? ` at ${err.source}:${err.lineno || '?'}` : ''}`, 'IFrame');
                            if(err.stack) console.error("IFrame Stack:", err.stack); // Log full stack to browser console for debugging
                           break;
                      case 'devtools-html-content':
                           // This message is handled by the promise in updateElementsView
                           break;
                       case 'devtools-execute-result':
                           // This message is handled by the promise in executeConsoleCommand
                           break;
                        case 'nexus-navigate-request':
                             // Handle navigation requests initiated from within an internal page iframe
                            if (data.url) {
                                 console.log(`[DevTools] Received navigation request from iframe: ${data.url}`);
                                 this.app.navigateTo(data.url); // Navigate in the main app context
                            }
                            break;

                      default:
                           // console.warn("[DevTools] Received unknown message type from iframe:", data.type, data);
                           break;
                 }
             }

             // --- Elements ---
             async updateElementsView() {
                 if (!this.isOpen || this.activePane !== 'elements') return; // Only update if visible

                 if (!this.activeTab || !this.activeTab.iframe || !this.activeTab.iframe.contentWindow) {
                     this.dom.elementsView.textContent = '// Select Elements pane and navigate to a page to inspect its source.';
                     return;
                 }

                 this.dom.elementsView.textContent = '// Requesting HTML source from iframe...';
                 const reqId = Utils.generateId('html_');

                 // Promise to wait for the HTML content message
                 const htmlPromise = new Promise((resolve, reject) => {
                      const listener = (event) => {
                           if (event.data && event.data.type === 'devtools-html-content' && event.data.reqId === reqId) {
                                window.removeEventListener('message', listener);
                                this.messageListeners.delete(reqId);
                                if (event.data.error) {
                                    reject(new Error(event.data.error));
                                } else {
                                     resolve(event.data.html || '// Received empty HTML content.');
                                 }
                             }
                      };
                      window.addEventListener('message', listener);
                      this.messageListeners.set(reqId, listener);
                         // Timeout
                         setTimeout(() => {
                              if (this.messageListeners.has(reqId)) {
                                   window.removeEventListener('message', listener);
                                   this.messageListeners.delete(reqId);
                                   reject(new Error(`Request for HTML content timed out (reqId: ${reqId})`));
                              }
                         }, 5000); // 5 second timeout
                  });

                  // Send request to iframe